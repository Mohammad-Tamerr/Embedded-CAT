In archive libCOTS.a:

DIO_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         0000066c  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000004fd  00000000  00000000  000006a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.DIO_Set_Pin_Direction 0000021e  00000000  00000000  00000b9d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.DIO_Set_Port_Direction 00000090  00000000  00000000  00000dbb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.DIO_Set_Pin_Value 00000224  00000000  00000000  00000e4b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.DIO_Set_Port_Value 00000090  00000000  00000000  0000106f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.DIO_Get_Pin_VALUE 00000130  00000000  00000000  000010ff  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.DIO_Set_Pin_Direction:

00000000 <DIO_Set_Pin_Direction>:
#define FUNCTION_NOT_OK 	1



u8 DIO_Set_Pin_Direction(u8 port_copy , u8 pin_copy , u8 direction_copy  )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	4c 83       	std	Y+4, r20	; 0x04
		u8 Local_Error_Status = FUNCTION_IS_OK ;
  1a:	19 82       	std	Y+1, r1	; 0x01
		if(pin_copy<=DIO_PIN_7)
  1c:	8b 81       	ldd	r24, Y+3	; 0x03
  1e:	88 30       	cpi	r24, 0x08	; 8
  20:	00 f0       	brcs	.+0      	; 0x22 <DIO_Set_Pin_Direction+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <DIO_Set_Pin_Direction+0x24>
		{
			if(direction_copy == DIO_PIN_INPUT)
  24:	8c 81       	ldd	r24, Y+4	; 0x04
  26:	88 23       	and	r24, r24
  28:	01 f0       	breq	.+0      	; 0x2a <DIO_Set_Pin_Direction+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <DIO_Set_Pin_Direction+0x2c>
			{
					switch(port_copy)
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	28 2f       	mov	r18, r24
  30:	30 e0       	ldi	r19, 0x00	; 0
  32:	38 87       	std	Y+8, r19	; 0x08
  34:	2f 83       	std	Y+7, r18	; 0x07
  36:	8f 81       	ldd	r24, Y+7	; 0x07
  38:	98 85       	ldd	r25, Y+8	; 0x08
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	91 05       	cpc	r25, r1
  3e:	01 f0       	breq	.+0      	; 0x40 <DIO_Set_Pin_Direction+0x40>
  40:	2f 81       	ldd	r18, Y+7	; 0x07
  42:	38 85       	ldd	r19, Y+8	; 0x08
  44:	22 30       	cpi	r18, 0x02	; 2
  46:	31 05       	cpc	r19, r1
  48:	04 f4       	brge	.+0      	; 0x4a <DIO_Set_Pin_Direction+0x4a>
  4a:	8f 81       	ldd	r24, Y+7	; 0x07
  4c:	98 85       	ldd	r25, Y+8	; 0x08
  4e:	00 97       	sbiw	r24, 0x00	; 0
  50:	01 f0       	breq	.+0      	; 0x52 <DIO_Set_Pin_Direction+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <DIO_Set_Pin_Direction+0x54>
  54:	2f 81       	ldd	r18, Y+7	; 0x07
  56:	38 85       	ldd	r19, Y+8	; 0x08
  58:	22 30       	cpi	r18, 0x02	; 2
  5a:	31 05       	cpc	r19, r1
  5c:	01 f0       	breq	.+0      	; 0x5e <DIO_Set_Pin_Direction+0x5e>
  5e:	8f 81       	ldd	r24, Y+7	; 0x07
  60:	98 85       	ldd	r25, Y+8	; 0x08
  62:	83 30       	cpi	r24, 0x03	; 3
  64:	91 05       	cpc	r25, r1
  66:	01 f4       	brne	.+0      	; 0x68 <DIO_Set_Pin_Direction+0x68>
  68:	00 c0       	rjmp	.+0      	; 0x6a <DIO_Set_Pin_Direction+0x6a>
  6a:	00 c0       	rjmp	.+0      	; 0x6c <DIO_Set_Pin_Direction+0x6c>
				{
						case DIO_PORT_A: CLR_BIT(DDR_A, pin_copy) ; break ;
  6c:	aa e3       	ldi	r26, 0x3A	; 58
  6e:	b0 e0       	ldi	r27, 0x00	; 0
  70:	ea e3       	ldi	r30, 0x3A	; 58
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	80 81       	ld	r24, Z
  76:	48 2f       	mov	r20, r24
  78:	8b 81       	ldd	r24, Y+3	; 0x03
  7a:	28 2f       	mov	r18, r24
  7c:	30 e0       	ldi	r19, 0x00	; 0
  7e:	81 e0       	ldi	r24, 0x01	; 1
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	02 2e       	mov	r0, r18
  84:	00 c0       	rjmp	.+0      	; 0x86 <DIO_Set_Pin_Direction+0x86>
  86:	88 0f       	add	r24, r24
  88:	99 1f       	adc	r25, r25
  8a:	0a 94       	dec	r0
  8c:	02 f4       	brpl	.+0      	; 0x8e <DIO_Set_Pin_Direction+0x8e>
  8e:	80 95       	com	r24
  90:	84 23       	and	r24, r20
  92:	8c 93       	st	X, r24
  94:	00 c0       	rjmp	.+0      	; 0x96 <DIO_Set_Pin_Direction+0x96>
						case DIO_PORT_B: CLR_BIT(DDR_B, pin_copy) ; break ;
  96:	a7 e3       	ldi	r26, 0x37	; 55
  98:	b0 e0       	ldi	r27, 0x00	; 0
  9a:	e7 e3       	ldi	r30, 0x37	; 55
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	80 81       	ld	r24, Z
  a0:	48 2f       	mov	r20, r24
  a2:	8b 81       	ldd	r24, Y+3	; 0x03
  a4:	28 2f       	mov	r18, r24
  a6:	30 e0       	ldi	r19, 0x00	; 0
  a8:	81 e0       	ldi	r24, 0x01	; 1
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	02 2e       	mov	r0, r18
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <DIO_Set_Pin_Direction+0xb0>
  b0:	88 0f       	add	r24, r24
  b2:	99 1f       	adc	r25, r25
  b4:	0a 94       	dec	r0
  b6:	02 f4       	brpl	.+0      	; 0xb8 <DIO_Set_Pin_Direction+0xb8>
  b8:	80 95       	com	r24
  ba:	84 23       	and	r24, r20
  bc:	8c 93       	st	X, r24
  be:	00 c0       	rjmp	.+0      	; 0xc0 <DIO_Set_Pin_Direction+0xc0>
						case DIO_PORT_C: CLR_BIT(DDR_C, pin_copy) ; break ;
  c0:	a4 e3       	ldi	r26, 0x34	; 52
  c2:	b0 e0       	ldi	r27, 0x00	; 0
  c4:	e4 e3       	ldi	r30, 0x34	; 52
  c6:	f0 e0       	ldi	r31, 0x00	; 0
  c8:	80 81       	ld	r24, Z
  ca:	48 2f       	mov	r20, r24
  cc:	8b 81       	ldd	r24, Y+3	; 0x03
  ce:	28 2f       	mov	r18, r24
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	90 e0       	ldi	r25, 0x00	; 0
  d6:	02 2e       	mov	r0, r18
  d8:	00 c0       	rjmp	.+0      	; 0xda <DIO_Set_Pin_Direction+0xda>
  da:	88 0f       	add	r24, r24
  dc:	99 1f       	adc	r25, r25
  de:	0a 94       	dec	r0
  e0:	02 f4       	brpl	.+0      	; 0xe2 <DIO_Set_Pin_Direction+0xe2>
  e2:	80 95       	com	r24
  e4:	84 23       	and	r24, r20
  e6:	8c 93       	st	X, r24
  e8:	00 c0       	rjmp	.+0      	; 0xea <DIO_Set_Pin_Direction+0xea>
						case DIO_PORT_D: CLR_BIT(DDR_D, pin_copy) ; break ;
  ea:	a1 e3       	ldi	r26, 0x31	; 49
  ec:	b0 e0       	ldi	r27, 0x00	; 0
  ee:	e1 e3       	ldi	r30, 0x31	; 49
  f0:	f0 e0       	ldi	r31, 0x00	; 0
  f2:	80 81       	ld	r24, Z
  f4:	48 2f       	mov	r20, r24
  f6:	8b 81       	ldd	r24, Y+3	; 0x03
  f8:	28 2f       	mov	r18, r24
  fa:	30 e0       	ldi	r19, 0x00	; 0
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	90 e0       	ldi	r25, 0x00	; 0
 100:	02 2e       	mov	r0, r18
 102:	00 c0       	rjmp	.+0      	; 0x104 <DIO_Set_Pin_Direction+0x104>
 104:	88 0f       	add	r24, r24
 106:	99 1f       	adc	r25, r25
 108:	0a 94       	dec	r0
 10a:	02 f4       	brpl	.+0      	; 0x10c <DIO_Set_Pin_Direction+0x10c>
 10c:	80 95       	com	r24
 10e:	84 23       	and	r24, r20
 110:	8c 93       	st	X, r24
 112:	00 c0       	rjmp	.+0      	; 0x114 <DIO_Set_Pin_Direction+0x114>
						default : Local_Error_Status = FUNCTION_NOT_OK ;
 114:	81 e0       	ldi	r24, 0x01	; 1
 116:	89 83       	std	Y+1, r24	; 0x01
 118:	00 c0       	rjmp	.+0      	; 0x11a <DIO_Set_Pin_Direction+0x11a>
				}
		}
		else if (direction_copy == DIO_PIN_OUTPUT)
 11a:	8c 81       	ldd	r24, Y+4	; 0x04
 11c:	81 30       	cpi	r24, 0x01	; 1
 11e:	01 f0       	breq	.+0      	; 0x120 <DIO_Set_Pin_Direction+0x120>
 120:	00 c0       	rjmp	.+0      	; 0x122 <DIO_Set_Pin_Direction+0x122>
		{
					switch (port_copy)
 122:	8a 81       	ldd	r24, Y+2	; 0x02
 124:	28 2f       	mov	r18, r24
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	3e 83       	std	Y+6, r19	; 0x06
 12a:	2d 83       	std	Y+5, r18	; 0x05
 12c:	8d 81       	ldd	r24, Y+5	; 0x05
 12e:	9e 81       	ldd	r25, Y+6	; 0x06
 130:	81 30       	cpi	r24, 0x01	; 1
 132:	91 05       	cpc	r25, r1
 134:	01 f0       	breq	.+0      	; 0x136 <DIO_Set_Pin_Direction+0x136>
 136:	2d 81       	ldd	r18, Y+5	; 0x05
 138:	3e 81       	ldd	r19, Y+6	; 0x06
 13a:	22 30       	cpi	r18, 0x02	; 2
 13c:	31 05       	cpc	r19, r1
 13e:	04 f4       	brge	.+0      	; 0x140 <DIO_Set_Pin_Direction+0x140>
 140:	8d 81       	ldd	r24, Y+5	; 0x05
 142:	9e 81       	ldd	r25, Y+6	; 0x06
 144:	00 97       	sbiw	r24, 0x00	; 0
 146:	01 f0       	breq	.+0      	; 0x148 <DIO_Set_Pin_Direction+0x148>
 148:	00 c0       	rjmp	.+0      	; 0x14a <DIO_Set_Pin_Direction+0x14a>
 14a:	2d 81       	ldd	r18, Y+5	; 0x05
 14c:	3e 81       	ldd	r19, Y+6	; 0x06
 14e:	22 30       	cpi	r18, 0x02	; 2
 150:	31 05       	cpc	r19, r1
 152:	01 f0       	breq	.+0      	; 0x154 <DIO_Set_Pin_Direction+0x154>
 154:	8d 81       	ldd	r24, Y+5	; 0x05
 156:	9e 81       	ldd	r25, Y+6	; 0x06
 158:	83 30       	cpi	r24, 0x03	; 3
 15a:	91 05       	cpc	r25, r1
 15c:	01 f0       	breq	.+0      	; 0x15e <DIO_Set_Pin_Direction+0x15e>
 15e:	00 c0       	rjmp	.+0      	; 0x160 <DIO_Set_Pin_Direction+0x160>
				{
					case DIO_PORT_A: SET_BIT(DDR_A, pin_copy) ; break ;
 160:	aa e3       	ldi	r26, 0x3A	; 58
 162:	b0 e0       	ldi	r27, 0x00	; 0
 164:	ea e3       	ldi	r30, 0x3A	; 58
 166:	f0 e0       	ldi	r31, 0x00	; 0
 168:	80 81       	ld	r24, Z
 16a:	48 2f       	mov	r20, r24
 16c:	8b 81       	ldd	r24, Y+3	; 0x03
 16e:	28 2f       	mov	r18, r24
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	81 e0       	ldi	r24, 0x01	; 1
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	02 2e       	mov	r0, r18
 178:	00 c0       	rjmp	.+0      	; 0x17a <DIO_Set_Pin_Direction+0x17a>
 17a:	88 0f       	add	r24, r24
 17c:	99 1f       	adc	r25, r25
 17e:	0a 94       	dec	r0
 180:	02 f4       	brpl	.+0      	; 0x182 <DIO_Set_Pin_Direction+0x182>
 182:	84 2b       	or	r24, r20
 184:	8c 93       	st	X, r24
 186:	00 c0       	rjmp	.+0      	; 0x188 <DIO_Set_Pin_Direction+0x188>
					case DIO_PORT_B: SET_BIT(DDR_B, pin_copy) ; break ;
 188:	a7 e3       	ldi	r26, 0x37	; 55
 18a:	b0 e0       	ldi	r27, 0x00	; 0
 18c:	e7 e3       	ldi	r30, 0x37	; 55
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	80 81       	ld	r24, Z
 192:	48 2f       	mov	r20, r24
 194:	8b 81       	ldd	r24, Y+3	; 0x03
 196:	28 2f       	mov	r18, r24
 198:	30 e0       	ldi	r19, 0x00	; 0
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	02 2e       	mov	r0, r18
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <DIO_Set_Pin_Direction+0x1a2>
 1a2:	88 0f       	add	r24, r24
 1a4:	99 1f       	adc	r25, r25
 1a6:	0a 94       	dec	r0
 1a8:	02 f4       	brpl	.+0      	; 0x1aa <DIO_Set_Pin_Direction+0x1aa>
 1aa:	84 2b       	or	r24, r20
 1ac:	8c 93       	st	X, r24
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <DIO_Set_Pin_Direction+0x1b0>
					case DIO_PORT_C: SET_BIT(DDR_C, pin_copy) ; break ;
 1b0:	a4 e3       	ldi	r26, 0x34	; 52
 1b2:	b0 e0       	ldi	r27, 0x00	; 0
 1b4:	e4 e3       	ldi	r30, 0x34	; 52
 1b6:	f0 e0       	ldi	r31, 0x00	; 0
 1b8:	80 81       	ld	r24, Z
 1ba:	48 2f       	mov	r20, r24
 1bc:	8b 81       	ldd	r24, Y+3	; 0x03
 1be:	28 2f       	mov	r18, r24
 1c0:	30 e0       	ldi	r19, 0x00	; 0
 1c2:	81 e0       	ldi	r24, 0x01	; 1
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	02 2e       	mov	r0, r18
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <DIO_Set_Pin_Direction+0x1ca>
 1ca:	88 0f       	add	r24, r24
 1cc:	99 1f       	adc	r25, r25
 1ce:	0a 94       	dec	r0
 1d0:	02 f4       	brpl	.+0      	; 0x1d2 <DIO_Set_Pin_Direction+0x1d2>
 1d2:	84 2b       	or	r24, r20
 1d4:	8c 93       	st	X, r24
 1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <DIO_Set_Pin_Direction+0x1d8>
					case DIO_PORT_D: SET_BIT(DDR_D, pin_copy) ; break ;
 1d8:	a1 e3       	ldi	r26, 0x31	; 49
 1da:	b0 e0       	ldi	r27, 0x00	; 0
 1dc:	e1 e3       	ldi	r30, 0x31	; 49
 1de:	f0 e0       	ldi	r31, 0x00	; 0
 1e0:	80 81       	ld	r24, Z
 1e2:	48 2f       	mov	r20, r24
 1e4:	8b 81       	ldd	r24, Y+3	; 0x03
 1e6:	28 2f       	mov	r18, r24
 1e8:	30 e0       	ldi	r19, 0x00	; 0
 1ea:	81 e0       	ldi	r24, 0x01	; 1
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	02 2e       	mov	r0, r18
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <DIO_Set_Pin_Direction+0x1f2>
 1f2:	88 0f       	add	r24, r24
 1f4:	99 1f       	adc	r25, r25
 1f6:	0a 94       	dec	r0
 1f8:	02 f4       	brpl	.+0      	; 0x1fa <DIO_Set_Pin_Direction+0x1fa>
 1fa:	84 2b       	or	r24, r20
 1fc:	8c 93       	st	X, r24
 1fe:	00 c0       	rjmp	.+0      	; 0x200 <DIO_Set_Pin_Direction+0x200>
					default : Local_Error_Status = FUNCTION_NOT_OK ;
 200:	81 e0       	ldi	r24, 0x01	; 1
 202:	89 83       	std	Y+1, r24	; 0x01
 204:	00 c0       	rjmp	.+0      	; 0x206 <DIO_Set_Pin_Direction+0x206>
				}
		}
		else
		{
				Local_Error_Status = FUNCTION_NOT_OK ;
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	89 83       	std	Y+1, r24	; 0x01
		}
}

	return Local_Error_Status;
 20a:	89 81       	ldd	r24, Y+1	; 0x01
}
 20c:	28 96       	adiw	r28, 0x08	; 8
 20e:	0f b6       	in	r0, 0x3f	; 63
 210:	f8 94       	cli
 212:	de bf       	out	0x3e, r29	; 62
 214:	0f be       	out	0x3f, r0	; 63
 216:	cd bf       	out	0x3d, r28	; 61
 218:	cf 91       	pop	r28
 21a:	df 91       	pop	r29
 21c:	08 95       	ret

Disassembly of section .text.DIO_Set_Port_Direction:

00000000 <DIO_Set_Port_Direction>:
#define FUNCTION_NOT_OK 	1



u8 DIO_Set_Pin_Direction(u8 port_copy , u8 pin_copy , u8 direction_copy  )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_Set_Port_Direction+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_Set_Port_Direction+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	8a 81       	ldd	r24, Y+2	; 0x02
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
		u8 Local_Error_Status = FUNCTION_IS_OK ;
  1a:	3d 83       	std	Y+5, r19	; 0x05
		if(pin_copy<=DIO_PIN_7)
  1c:	2c 83       	std	Y+4, r18	; 0x04
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	81 30       	cpi	r24, 0x01	; 1
		{
			if(direction_copy == DIO_PIN_INPUT)
  24:	91 05       	cpc	r25, r1
  26:	01 f0       	breq	.+0      	; 0x28 <DIO_Set_Port_Direction+0x28>
  28:	2c 81       	ldd	r18, Y+4	; 0x04
  2a:	3d 81       	ldd	r19, Y+5	; 0x05
			{
					switch(port_copy)
  2c:	22 30       	cpi	r18, 0x02	; 2
  2e:	31 05       	cpc	r19, r1
  30:	04 f4       	brge	.+0      	; 0x32 <DIO_Set_Port_Direction+0x32>
  32:	8c 81       	ldd	r24, Y+4	; 0x04
  34:	9d 81       	ldd	r25, Y+5	; 0x05
  36:	00 97       	sbiw	r24, 0x00	; 0
  38:	01 f0       	breq	.+0      	; 0x3a <DIO_Set_Port_Direction+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <DIO_Set_Port_Direction+0x3c>
  3c:	2c 81       	ldd	r18, Y+4	; 0x04
  3e:	3d 81       	ldd	r19, Y+5	; 0x05
  40:	22 30       	cpi	r18, 0x02	; 2
  42:	31 05       	cpc	r19, r1
  44:	01 f0       	breq	.+0      	; 0x46 <DIO_Set_Port_Direction+0x46>
  46:	8c 81       	ldd	r24, Y+4	; 0x04
  48:	9d 81       	ldd	r25, Y+5	; 0x05
  4a:	83 30       	cpi	r24, 0x03	; 3
  4c:	91 05       	cpc	r25, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <DIO_Set_Port_Direction+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <DIO_Set_Port_Direction+0x52>
  52:	eb e3       	ldi	r30, 0x3B	; 59
  54:	f0 e0       	ldi	r31, 0x00	; 0
  56:	8b 81       	ldd	r24, Y+3	; 0x03
  58:	80 83       	st	Z, r24
  5a:	00 c0       	rjmp	.+0      	; 0x5c <DIO_Set_Port_Direction+0x5c>
  5c:	e8 e3       	ldi	r30, 0x38	; 56
  5e:	f0 e0       	ldi	r31, 0x00	; 0
  60:	8b 81       	ldd	r24, Y+3	; 0x03
  62:	80 83       	st	Z, r24
  64:	00 c0       	rjmp	.+0      	; 0x66 <DIO_Set_Port_Direction+0x66>
  66:	e5 e3       	ldi	r30, 0x35	; 53
  68:	f0 e0       	ldi	r31, 0x00	; 0
  6a:	8b 81       	ldd	r24, Y+3	; 0x03
				{
						case DIO_PORT_A: CLR_BIT(DDR_A, pin_copy) ; break ;
  6c:	80 83       	st	Z, r24
  6e:	00 c0       	rjmp	.+0      	; 0x70 <DIO_Set_Port_Direction+0x70>
  70:	e2 e3       	ldi	r30, 0x32	; 50
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	8b 81       	ldd	r24, Y+3	; 0x03
  76:	80 83       	st	Z, r24
  78:	00 c0       	rjmp	.+0      	; 0x7a <DIO_Set_Port_Direction+0x7a>
  7a:	81 e0       	ldi	r24, 0x01	; 1
  7c:	89 83       	std	Y+1, r24	; 0x01
  7e:	89 81       	ldd	r24, Y+1	; 0x01
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	cf 91       	pop	r28
  8c:	df 91       	pop	r29
  8e:	08 95       	ret

Disassembly of section .text.DIO_Set_Pin_Value:

00000000 <DIO_Set_Pin_Value>:
#define FUNCTION_NOT_OK 	1



u8 DIO_Set_Pin_Direction(u8 port_copy , u8 pin_copy , u8 direction_copy  )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	4c 83       	std	Y+4, r20	; 0x04
		u8 Local_Error_Status = FUNCTION_IS_OK ;
  1a:	19 82       	std	Y+1, r1	; 0x01
		if(pin_copy<=DIO_PIN_7)
  1c:	8b 81       	ldd	r24, Y+3	; 0x03
  1e:	88 30       	cpi	r24, 0x08	; 8
  20:	00 f0       	brcs	.+0      	; 0x22 <DIO_Set_Pin_Value+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <DIO_Set_Pin_Value+0x24>
		{
			if(direction_copy == DIO_PIN_INPUT)
  24:	8c 81       	ldd	r24, Y+4	; 0x04
  26:	88 23       	and	r24, r24
  28:	01 f0       	breq	.+0      	; 0x2a <DIO_Set_Pin_Value+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <DIO_Set_Pin_Value+0x2c>
			{
					switch(port_copy)
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	28 2f       	mov	r18, r24
  30:	30 e0       	ldi	r19, 0x00	; 0
  32:	38 87       	std	Y+8, r19	; 0x08
  34:	2f 83       	std	Y+7, r18	; 0x07
  36:	8f 81       	ldd	r24, Y+7	; 0x07
  38:	98 85       	ldd	r25, Y+8	; 0x08
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	91 05       	cpc	r25, r1
  3e:	01 f0       	breq	.+0      	; 0x40 <DIO_Set_Pin_Value+0x40>
  40:	2f 81       	ldd	r18, Y+7	; 0x07
  42:	38 85       	ldd	r19, Y+8	; 0x08
  44:	22 30       	cpi	r18, 0x02	; 2
  46:	31 05       	cpc	r19, r1
  48:	04 f4       	brge	.+0      	; 0x4a <DIO_Set_Pin_Value+0x4a>
  4a:	8f 81       	ldd	r24, Y+7	; 0x07
  4c:	98 85       	ldd	r25, Y+8	; 0x08
  4e:	00 97       	sbiw	r24, 0x00	; 0
  50:	01 f0       	breq	.+0      	; 0x52 <DIO_Set_Pin_Value+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <DIO_Set_Pin_Value+0x54>
  54:	2f 81       	ldd	r18, Y+7	; 0x07
  56:	38 85       	ldd	r19, Y+8	; 0x08
  58:	22 30       	cpi	r18, 0x02	; 2
  5a:	31 05       	cpc	r19, r1
  5c:	01 f0       	breq	.+0      	; 0x5e <DIO_Set_Pin_Value+0x5e>
  5e:	8f 81       	ldd	r24, Y+7	; 0x07
  60:	98 85       	ldd	r25, Y+8	; 0x08
  62:	83 30       	cpi	r24, 0x03	; 3
  64:	91 05       	cpc	r25, r1
  66:	01 f4       	brne	.+0      	; 0x68 <DIO_Set_Pin_Value+0x68>
  68:	00 c0       	rjmp	.+0      	; 0x6a <DIO_Set_Pin_Value+0x6a>
  6a:	00 c0       	rjmp	.+0      	; 0x6c <DIO_Set_Pin_Value+0x6c>
				{
						case DIO_PORT_A: CLR_BIT(DDR_A, pin_copy) ; break ;
  6c:	ab e3       	ldi	r26, 0x3B	; 59
  6e:	b0 e0       	ldi	r27, 0x00	; 0
  70:	eb e3       	ldi	r30, 0x3B	; 59
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	80 81       	ld	r24, Z
  76:	48 2f       	mov	r20, r24
  78:	8b 81       	ldd	r24, Y+3	; 0x03
  7a:	28 2f       	mov	r18, r24
  7c:	30 e0       	ldi	r19, 0x00	; 0
  7e:	81 e0       	ldi	r24, 0x01	; 1
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	02 2e       	mov	r0, r18
  84:	00 c0       	rjmp	.+0      	; 0x86 <DIO_Set_Pin_Value+0x86>
  86:	88 0f       	add	r24, r24
  88:	99 1f       	adc	r25, r25
  8a:	0a 94       	dec	r0
  8c:	02 f4       	brpl	.+0      	; 0x8e <DIO_Set_Pin_Value+0x8e>
  8e:	80 95       	com	r24
  90:	84 23       	and	r24, r20
  92:	8c 93       	st	X, r24
  94:	00 c0       	rjmp	.+0      	; 0x96 <DIO_Set_Pin_Value+0x96>
						case DIO_PORT_B: CLR_BIT(DDR_B, pin_copy) ; break ;
  96:	a8 e3       	ldi	r26, 0x38	; 56
  98:	b0 e0       	ldi	r27, 0x00	; 0
  9a:	e8 e3       	ldi	r30, 0x38	; 56
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	80 81       	ld	r24, Z
  a0:	48 2f       	mov	r20, r24
  a2:	8b 81       	ldd	r24, Y+3	; 0x03
  a4:	28 2f       	mov	r18, r24
  a6:	30 e0       	ldi	r19, 0x00	; 0
  a8:	81 e0       	ldi	r24, 0x01	; 1
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	02 2e       	mov	r0, r18
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <DIO_Set_Pin_Value+0xb0>
  b0:	88 0f       	add	r24, r24
  b2:	99 1f       	adc	r25, r25
  b4:	0a 94       	dec	r0
  b6:	02 f4       	brpl	.+0      	; 0xb8 <DIO_Set_Pin_Value+0xb8>
  b8:	80 95       	com	r24
  ba:	84 23       	and	r24, r20
  bc:	8c 93       	st	X, r24
  be:	00 c0       	rjmp	.+0      	; 0xc0 <DIO_Set_Pin_Value+0xc0>
						case DIO_PORT_C: CLR_BIT(DDR_C, pin_copy) ; break ;
  c0:	a5 e3       	ldi	r26, 0x35	; 53
  c2:	b0 e0       	ldi	r27, 0x00	; 0
  c4:	e5 e3       	ldi	r30, 0x35	; 53
  c6:	f0 e0       	ldi	r31, 0x00	; 0
  c8:	80 81       	ld	r24, Z
  ca:	48 2f       	mov	r20, r24
  cc:	8b 81       	ldd	r24, Y+3	; 0x03
  ce:	28 2f       	mov	r18, r24
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	81 e0       	ldi	r24, 0x01	; 1
  d4:	90 e0       	ldi	r25, 0x00	; 0
  d6:	02 2e       	mov	r0, r18
  d8:	00 c0       	rjmp	.+0      	; 0xda <DIO_Set_Pin_Value+0xda>
  da:	88 0f       	add	r24, r24
  dc:	99 1f       	adc	r25, r25
  de:	0a 94       	dec	r0
  e0:	02 f4       	brpl	.+0      	; 0xe2 <DIO_Set_Pin_Value+0xe2>
  e2:	80 95       	com	r24
  e4:	84 23       	and	r24, r20
  e6:	8c 93       	st	X, r24
  e8:	00 c0       	rjmp	.+0      	; 0xea <DIO_Set_Pin_Value+0xea>
						case DIO_PORT_D: CLR_BIT(DDR_D, pin_copy) ; break ;
  ea:	a2 e3       	ldi	r26, 0x32	; 50
  ec:	b0 e0       	ldi	r27, 0x00	; 0
  ee:	e2 e3       	ldi	r30, 0x32	; 50
  f0:	f0 e0       	ldi	r31, 0x00	; 0
  f2:	80 81       	ld	r24, Z
  f4:	48 2f       	mov	r20, r24
  f6:	8b 81       	ldd	r24, Y+3	; 0x03
  f8:	28 2f       	mov	r18, r24
  fa:	30 e0       	ldi	r19, 0x00	; 0
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	90 e0       	ldi	r25, 0x00	; 0
 100:	02 2e       	mov	r0, r18
 102:	00 c0       	rjmp	.+0      	; 0x104 <DIO_Set_Pin_Value+0x104>
 104:	88 0f       	add	r24, r24
 106:	99 1f       	adc	r25, r25
 108:	0a 94       	dec	r0
 10a:	02 f4       	brpl	.+0      	; 0x10c <DIO_Set_Pin_Value+0x10c>
 10c:	80 95       	com	r24
 10e:	84 23       	and	r24, r20
 110:	8c 93       	st	X, r24
 112:	00 c0       	rjmp	.+0      	; 0x114 <DIO_Set_Pin_Value+0x114>
						default : Local_Error_Status = FUNCTION_NOT_OK ;
 114:	81 e0       	ldi	r24, 0x01	; 1
 116:	89 83       	std	Y+1, r24	; 0x01
 118:	00 c0       	rjmp	.+0      	; 0x11a <DIO_Set_Pin_Value+0x11a>
				}
		}
		else if (direction_copy == DIO_PIN_OUTPUT)
 11a:	8c 81       	ldd	r24, Y+4	; 0x04
 11c:	81 30       	cpi	r24, 0x01	; 1
 11e:	01 f0       	breq	.+0      	; 0x120 <DIO_Set_Pin_Value+0x120>
 120:	00 c0       	rjmp	.+0      	; 0x122 <DIO_Set_Pin_Value+0x122>
		{
					switch (port_copy)
 122:	8a 81       	ldd	r24, Y+2	; 0x02
 124:	28 2f       	mov	r18, r24
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	3e 83       	std	Y+6, r19	; 0x06
 12a:	2d 83       	std	Y+5, r18	; 0x05
 12c:	8d 81       	ldd	r24, Y+5	; 0x05
 12e:	9e 81       	ldd	r25, Y+6	; 0x06
 130:	81 30       	cpi	r24, 0x01	; 1
 132:	91 05       	cpc	r25, r1
 134:	01 f0       	breq	.+0      	; 0x136 <DIO_Set_Pin_Value+0x136>
 136:	2d 81       	ldd	r18, Y+5	; 0x05
 138:	3e 81       	ldd	r19, Y+6	; 0x06
 13a:	22 30       	cpi	r18, 0x02	; 2
 13c:	31 05       	cpc	r19, r1
 13e:	04 f4       	brge	.+0      	; 0x140 <DIO_Set_Pin_Value+0x140>
 140:	8d 81       	ldd	r24, Y+5	; 0x05
 142:	9e 81       	ldd	r25, Y+6	; 0x06
 144:	00 97       	sbiw	r24, 0x00	; 0
 146:	01 f0       	breq	.+0      	; 0x148 <DIO_Set_Pin_Value+0x148>
 148:	00 c0       	rjmp	.+0      	; 0x14a <DIO_Set_Pin_Value+0x14a>
 14a:	2d 81       	ldd	r18, Y+5	; 0x05
 14c:	3e 81       	ldd	r19, Y+6	; 0x06
 14e:	22 30       	cpi	r18, 0x02	; 2
 150:	31 05       	cpc	r19, r1
 152:	01 f0       	breq	.+0      	; 0x154 <DIO_Set_Pin_Value+0x154>
 154:	8d 81       	ldd	r24, Y+5	; 0x05
 156:	9e 81       	ldd	r25, Y+6	; 0x06
 158:	83 30       	cpi	r24, 0x03	; 3
 15a:	91 05       	cpc	r25, r1
 15c:	01 f0       	breq	.+0      	; 0x15e <DIO_Set_Pin_Value+0x15e>
 15e:	00 c0       	rjmp	.+0      	; 0x160 <DIO_Set_Pin_Value+0x160>
				{
					case DIO_PORT_A: SET_BIT(DDR_A, pin_copy) ; break ;
 160:	ab e3       	ldi	r26, 0x3B	; 59
 162:	b0 e0       	ldi	r27, 0x00	; 0
 164:	eb e3       	ldi	r30, 0x3B	; 59
 166:	f0 e0       	ldi	r31, 0x00	; 0
 168:	80 81       	ld	r24, Z
 16a:	48 2f       	mov	r20, r24
 16c:	8b 81       	ldd	r24, Y+3	; 0x03
 16e:	28 2f       	mov	r18, r24
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	81 e0       	ldi	r24, 0x01	; 1
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	02 2e       	mov	r0, r18
 178:	00 c0       	rjmp	.+0      	; 0x17a <DIO_Set_Pin_Value+0x17a>
 17a:	88 0f       	add	r24, r24
 17c:	99 1f       	adc	r25, r25
 17e:	0a 94       	dec	r0
 180:	02 f4       	brpl	.+0      	; 0x182 <DIO_Set_Pin_Value+0x182>
 182:	84 2b       	or	r24, r20
 184:	8c 93       	st	X, r24
 186:	00 c0       	rjmp	.+0      	; 0x188 <DIO_Set_Pin_Value+0x188>
					case DIO_PORT_B: SET_BIT(DDR_B, pin_copy) ; break ;
 188:	a8 e3       	ldi	r26, 0x38	; 56
 18a:	b0 e0       	ldi	r27, 0x00	; 0
 18c:	e8 e3       	ldi	r30, 0x38	; 56
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	80 81       	ld	r24, Z
 192:	48 2f       	mov	r20, r24
 194:	8b 81       	ldd	r24, Y+3	; 0x03
 196:	28 2f       	mov	r18, r24
 198:	30 e0       	ldi	r19, 0x00	; 0
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	02 2e       	mov	r0, r18
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <DIO_Set_Pin_Value+0x1a2>
 1a2:	88 0f       	add	r24, r24
 1a4:	99 1f       	adc	r25, r25
 1a6:	0a 94       	dec	r0
 1a8:	02 f4       	brpl	.+0      	; 0x1aa <DIO_Set_Pin_Value+0x1aa>
 1aa:	84 2b       	or	r24, r20
 1ac:	8c 93       	st	X, r24
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <DIO_Set_Pin_Value+0x1b0>
					case DIO_PORT_C: SET_BIT(DDR_C, pin_copy) ; break ;
 1b0:	a5 e3       	ldi	r26, 0x35	; 53
 1b2:	b0 e0       	ldi	r27, 0x00	; 0
 1b4:	e5 e3       	ldi	r30, 0x35	; 53
 1b6:	f0 e0       	ldi	r31, 0x00	; 0
 1b8:	80 81       	ld	r24, Z
 1ba:	48 2f       	mov	r20, r24
 1bc:	8b 81       	ldd	r24, Y+3	; 0x03
 1be:	28 2f       	mov	r18, r24
 1c0:	30 e0       	ldi	r19, 0x00	; 0
 1c2:	81 e0       	ldi	r24, 0x01	; 1
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	02 2e       	mov	r0, r18
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <DIO_Set_Pin_Value+0x1ca>
 1ca:	88 0f       	add	r24, r24
 1cc:	99 1f       	adc	r25, r25
 1ce:	0a 94       	dec	r0
 1d0:	02 f4       	brpl	.+0      	; 0x1d2 <DIO_Set_Pin_Value+0x1d2>
 1d2:	84 2b       	or	r24, r20
 1d4:	8c 93       	st	X, r24
 1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <DIO_Set_Pin_Value+0x1d8>
					case DIO_PORT_D: SET_BIT(DDR_D, pin_copy) ; break ;
 1d8:	a2 e3       	ldi	r26, 0x32	; 50
 1da:	b0 e0       	ldi	r27, 0x00	; 0
 1dc:	e2 e3       	ldi	r30, 0x32	; 50
 1de:	f0 e0       	ldi	r31, 0x00	; 0
 1e0:	80 81       	ld	r24, Z
 1e2:	48 2f       	mov	r20, r24
 1e4:	8b 81       	ldd	r24, Y+3	; 0x03
 1e6:	28 2f       	mov	r18, r24
 1e8:	30 e0       	ldi	r19, 0x00	; 0
 1ea:	81 e0       	ldi	r24, 0x01	; 1
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	02 2e       	mov	r0, r18
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <DIO_Set_Pin_Value+0x1f2>
 1f2:	88 0f       	add	r24, r24
 1f4:	99 1f       	adc	r25, r25
 1f6:	0a 94       	dec	r0
 1f8:	02 f4       	brpl	.+0      	; 0x1fa <DIO_Set_Pin_Value+0x1fa>
 1fa:	84 2b       	or	r24, r20
 1fc:	8c 93       	st	X, r24
 1fe:	00 c0       	rjmp	.+0      	; 0x200 <DIO_Set_Pin_Value+0x200>
					default : Local_Error_Status = FUNCTION_NOT_OK ;
 200:	81 e0       	ldi	r24, 0x01	; 1
 202:	89 83       	std	Y+1, r24	; 0x01
 204:	00 c0       	rjmp	.+0      	; 0x206 <DIO_Set_Pin_Value+0x206>
				}
		}
		else
		{
				Local_Error_Status = FUNCTION_NOT_OK ;
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	89 83       	std	Y+1, r24	; 0x01
		}
}

	return Local_Error_Status;
 20a:	00 c0       	rjmp	.+0      	; 0x20c <DIO_Set_Pin_Value+0x20c>
}
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	89 83       	std	Y+1, r24	; 0x01
 210:	89 81       	ldd	r24, Y+1	; 0x01
 212:	28 96       	adiw	r28, 0x08	; 8
 214:	0f b6       	in	r0, 0x3f	; 63
 216:	f8 94       	cli
 218:	de bf       	out	0x3e, r29	; 62
 21a:	0f be       	out	0x3f, r0	; 63
 21c:	cd bf       	out	0x3d, r28	; 61
 21e:	cf 91       	pop	r28
 220:	df 91       	pop	r29
 222:	08 95       	ret

Disassembly of section .text.DIO_Set_Port_Value:

00000000 <DIO_Set_Port_Value>:
#define FUNCTION_NOT_OK 	1



u8 DIO_Set_Pin_Direction(u8 port_copy , u8 pin_copy , u8 direction_copy  )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <DIO_Set_Port_Value+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <DIO_Set_Port_Value+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	8a 81       	ldd	r24, Y+2	; 0x02
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
		u8 Local_Error_Status = FUNCTION_IS_OK ;
  1a:	3d 83       	std	Y+5, r19	; 0x05
		if(pin_copy<=DIO_PIN_7)
  1c:	2c 83       	std	Y+4, r18	; 0x04
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	81 30       	cpi	r24, 0x01	; 1
		{
			if(direction_copy == DIO_PIN_INPUT)
  24:	91 05       	cpc	r25, r1
  26:	01 f0       	breq	.+0      	; 0x28 <DIO_Set_Port_Value+0x28>
  28:	2c 81       	ldd	r18, Y+4	; 0x04
  2a:	3d 81       	ldd	r19, Y+5	; 0x05
			{
					switch(port_copy)
  2c:	22 30       	cpi	r18, 0x02	; 2
  2e:	31 05       	cpc	r19, r1
  30:	04 f4       	brge	.+0      	; 0x32 <DIO_Set_Port_Value+0x32>
  32:	8c 81       	ldd	r24, Y+4	; 0x04
  34:	9d 81       	ldd	r25, Y+5	; 0x05
  36:	00 97       	sbiw	r24, 0x00	; 0
  38:	01 f0       	breq	.+0      	; 0x3a <DIO_Set_Port_Value+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <DIO_Set_Port_Value+0x3c>
  3c:	2c 81       	ldd	r18, Y+4	; 0x04
  3e:	3d 81       	ldd	r19, Y+5	; 0x05
  40:	22 30       	cpi	r18, 0x02	; 2
  42:	31 05       	cpc	r19, r1
  44:	01 f0       	breq	.+0      	; 0x46 <DIO_Set_Port_Value+0x46>
  46:	8c 81       	ldd	r24, Y+4	; 0x04
  48:	9d 81       	ldd	r25, Y+5	; 0x05
  4a:	83 30       	cpi	r24, 0x03	; 3
  4c:	91 05       	cpc	r25, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <DIO_Set_Port_Value+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <DIO_Set_Port_Value+0x52>
  52:	eb e3       	ldi	r30, 0x3B	; 59
  54:	f0 e0       	ldi	r31, 0x00	; 0
  56:	8b 81       	ldd	r24, Y+3	; 0x03
  58:	80 83       	st	Z, r24
  5a:	00 c0       	rjmp	.+0      	; 0x5c <DIO_Set_Port_Value+0x5c>
  5c:	e8 e3       	ldi	r30, 0x38	; 56
  5e:	f0 e0       	ldi	r31, 0x00	; 0
  60:	8b 81       	ldd	r24, Y+3	; 0x03
  62:	80 83       	st	Z, r24
  64:	00 c0       	rjmp	.+0      	; 0x66 <DIO_Set_Port_Value+0x66>
  66:	e5 e3       	ldi	r30, 0x35	; 53
  68:	f0 e0       	ldi	r31, 0x00	; 0
  6a:	8b 81       	ldd	r24, Y+3	; 0x03
				{
						case DIO_PORT_A: CLR_BIT(DDR_A, pin_copy) ; break ;
  6c:	80 83       	st	Z, r24
  6e:	00 c0       	rjmp	.+0      	; 0x70 <DIO_Set_Port_Value+0x70>
  70:	e2 e3       	ldi	r30, 0x32	; 50
  72:	f0 e0       	ldi	r31, 0x00	; 0
  74:	8b 81       	ldd	r24, Y+3	; 0x03
  76:	80 83       	st	Z, r24
  78:	00 c0       	rjmp	.+0      	; 0x7a <DIO_Set_Port_Value+0x7a>
  7a:	81 e0       	ldi	r24, 0x01	; 1
  7c:	89 83       	std	Y+1, r24	; 0x01
  7e:	89 81       	ldd	r24, Y+1	; 0x01
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	cf 91       	pop	r28
  8c:	df 91       	pop	r29
  8e:	08 95       	ret

Disassembly of section .text.DIO_Get_Pin_VALUE:

00000000 <DIO_Get_Pin_VALUE>:
#define FUNCTION_NOT_OK 	1



u8 DIO_Set_Pin_Direction(u8 port_copy , u8 pin_copy , u8 direction_copy  )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	27 97       	sbiw	r28, 0x07	; 7
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8a 83       	std	Y+2, r24	; 0x02
  16:	6b 83       	std	Y+3, r22	; 0x03
  18:	5d 83       	std	Y+5, r21	; 0x05
		u8 Local_Error_Status = FUNCTION_IS_OK ;
  1a:	4c 83       	std	Y+4, r20	; 0x04
		if(pin_copy<=DIO_PIN_7)
  1c:	19 82       	std	Y+1, r1	; 0x01
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	00 97       	sbiw	r24, 0x00	; 0
		{
			if(direction_copy == DIO_PIN_INPUT)
  24:	01 f4       	brne	.+0      	; 0x26 <DIO_Get_Pin_VALUE+0x26>
  26:	00 c0       	rjmp	.+0      	; 0x28 <DIO_Get_Pin_VALUE+0x28>
  28:	8b 81       	ldd	r24, Y+3	; 0x03
  2a:	88 30       	cpi	r24, 0x08	; 8
			{
					switch(port_copy)
  2c:	00 f0       	brcs	.+0      	; 0x2e <DIO_Get_Pin_VALUE+0x2e>
  2e:	00 c0       	rjmp	.+0      	; 0x30 <DIO_Get_Pin_VALUE+0x30>
  30:	8a 81       	ldd	r24, Y+2	; 0x02
  32:	28 2f       	mov	r18, r24
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	3f 83       	std	Y+7, r19	; 0x07
  38:	2e 83       	std	Y+6, r18	; 0x06
  3a:	4e 81       	ldd	r20, Y+6	; 0x06
  3c:	5f 81       	ldd	r21, Y+7	; 0x07
  3e:	41 30       	cpi	r20, 0x01	; 1
  40:	51 05       	cpc	r21, r1
  42:	01 f0       	breq	.+0      	; 0x44 <DIO_Get_Pin_VALUE+0x44>
  44:	8e 81       	ldd	r24, Y+6	; 0x06
  46:	9f 81       	ldd	r25, Y+7	; 0x07
  48:	82 30       	cpi	r24, 0x02	; 2
  4a:	91 05       	cpc	r25, r1
  4c:	04 f4       	brge	.+0      	; 0x4e <DIO_Get_Pin_VALUE+0x4e>
  4e:	2e 81       	ldd	r18, Y+6	; 0x06
  50:	3f 81       	ldd	r19, Y+7	; 0x07
  52:	21 15       	cp	r18, r1
  54:	31 05       	cpc	r19, r1
  56:	01 f0       	breq	.+0      	; 0x58 <DIO_Get_Pin_VALUE+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <DIO_Get_Pin_VALUE+0x5a>
  5a:	4e 81       	ldd	r20, Y+6	; 0x06
  5c:	5f 81       	ldd	r21, Y+7	; 0x07
  5e:	42 30       	cpi	r20, 0x02	; 2
  60:	51 05       	cpc	r21, r1
  62:	01 f0       	breq	.+0      	; 0x64 <DIO_Get_Pin_VALUE+0x64>
  64:	8e 81       	ldd	r24, Y+6	; 0x06
  66:	9f 81       	ldd	r25, Y+7	; 0x07
  68:	83 30       	cpi	r24, 0x03	; 3
  6a:	91 05       	cpc	r25, r1
				{
						case DIO_PORT_A: CLR_BIT(DDR_A, pin_copy) ; break ;
  6c:	01 f4       	brne	.+0      	; 0x6e <DIO_Get_Pin_VALUE+0x6e>
  6e:	00 c0       	rjmp	.+0      	; 0x70 <DIO_Get_Pin_VALUE+0x70>
  70:	00 c0       	rjmp	.+0      	; 0x72 <DIO_Get_Pin_VALUE+0x72>
  72:	e9 e3       	ldi	r30, 0x39	; 57
  74:	f0 e0       	ldi	r31, 0x00	; 0
  76:	80 81       	ld	r24, Z
  78:	28 2f       	mov	r18, r24
  7a:	30 e0       	ldi	r19, 0x00	; 0
  7c:	8a 81       	ldd	r24, Y+2	; 0x02
  7e:	88 2f       	mov	r24, r24
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	a9 01       	movw	r20, r18
  84:	00 c0       	rjmp	.+0      	; 0x86 <DIO_Get_Pin_VALUE+0x86>
  86:	55 95       	asr	r21
  88:	47 95       	ror	r20
  8a:	8a 95       	dec	r24
  8c:	02 f4       	brpl	.+0      	; 0x8e <DIO_Get_Pin_VALUE+0x8e>
  8e:	ca 01       	movw	r24, r20
  90:	81 70       	andi	r24, 0x01	; 1
  92:	ec 81       	ldd	r30, Y+4	; 0x04
  94:	fd 81       	ldd	r31, Y+5	; 0x05
						case DIO_PORT_B: CLR_BIT(DDR_B, pin_copy) ; break ;
  96:	80 83       	st	Z, r24
  98:	00 c0       	rjmp	.+0      	; 0x9a <DIO_Get_Pin_VALUE+0x9a>
  9a:	e6 e3       	ldi	r30, 0x36	; 54
  9c:	f0 e0       	ldi	r31, 0x00	; 0
  9e:	80 81       	ld	r24, Z
  a0:	28 2f       	mov	r18, r24
  a2:	30 e0       	ldi	r19, 0x00	; 0
  a4:	8a 81       	ldd	r24, Y+2	; 0x02
  a6:	88 2f       	mov	r24, r24
  a8:	90 e0       	ldi	r25, 0x00	; 0
  aa:	a9 01       	movw	r20, r18
  ac:	00 c0       	rjmp	.+0      	; 0xae <DIO_Get_Pin_VALUE+0xae>
  ae:	55 95       	asr	r21
  b0:	47 95       	ror	r20
  b2:	8a 95       	dec	r24
  b4:	02 f4       	brpl	.+0      	; 0xb6 <DIO_Get_Pin_VALUE+0xb6>
  b6:	ca 01       	movw	r24, r20
  b8:	81 70       	andi	r24, 0x01	; 1
  ba:	ec 81       	ldd	r30, Y+4	; 0x04
  bc:	fd 81       	ldd	r31, Y+5	; 0x05
  be:	80 83       	st	Z, r24
						case DIO_PORT_C: CLR_BIT(DDR_C, pin_copy) ; break ;
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <DIO_Get_Pin_VALUE+0xc2>
  c2:	e3 e3       	ldi	r30, 0x33	; 51
  c4:	f0 e0       	ldi	r31, 0x00	; 0
  c6:	80 81       	ld	r24, Z
  c8:	28 2f       	mov	r18, r24
  ca:	30 e0       	ldi	r19, 0x00	; 0
  cc:	8a 81       	ldd	r24, Y+2	; 0x02
  ce:	88 2f       	mov	r24, r24
  d0:	90 e0       	ldi	r25, 0x00	; 0
  d2:	a9 01       	movw	r20, r18
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <DIO_Get_Pin_VALUE+0xd6>
  d6:	55 95       	asr	r21
  d8:	47 95       	ror	r20
  da:	8a 95       	dec	r24
  dc:	02 f4       	brpl	.+0      	; 0xde <DIO_Get_Pin_VALUE+0xde>
  de:	ca 01       	movw	r24, r20
  e0:	81 70       	andi	r24, 0x01	; 1
  e2:	ec 81       	ldd	r30, Y+4	; 0x04
  e4:	fd 81       	ldd	r31, Y+5	; 0x05
  e6:	80 83       	st	Z, r24
  e8:	00 c0       	rjmp	.+0      	; 0xea <DIO_Get_Pin_VALUE+0xea>
						case DIO_PORT_D: CLR_BIT(DDR_D, pin_copy) ; break ;
  ea:	e0 e3       	ldi	r30, 0x30	; 48
  ec:	f0 e0       	ldi	r31, 0x00	; 0
  ee:	80 81       	ld	r24, Z
  f0:	28 2f       	mov	r18, r24
  f2:	30 e0       	ldi	r19, 0x00	; 0
  f4:	8a 81       	ldd	r24, Y+2	; 0x02
  f6:	88 2f       	mov	r24, r24
  f8:	90 e0       	ldi	r25, 0x00	; 0
  fa:	a9 01       	movw	r20, r18
  fc:	00 c0       	rjmp	.+0      	; 0xfe <DIO_Get_Pin_VALUE+0xfe>
  fe:	55 95       	asr	r21
 100:	47 95       	ror	r20
 102:	8a 95       	dec	r24
 104:	02 f4       	brpl	.+0      	; 0x106 <DIO_Get_Pin_VALUE+0x106>
 106:	ca 01       	movw	r24, r20
 108:	81 70       	andi	r24, 0x01	; 1
 10a:	ec 81       	ldd	r30, Y+4	; 0x04
 10c:	fd 81       	ldd	r31, Y+5	; 0x05
 10e:	80 83       	st	Z, r24
 110:	00 c0       	rjmp	.+0      	; 0x112 <DIO_Get_Pin_VALUE+0x112>
 112:	81 e0       	ldi	r24, 0x01	; 1
						default : Local_Error_Status = FUNCTION_NOT_OK ;
 114:	89 83       	std	Y+1, r24	; 0x01
 116:	00 c0       	rjmp	.+0      	; 0x118 <DIO_Get_Pin_VALUE+0x118>
 118:	81 e0       	ldi	r24, 0x01	; 1
				}
		}
		else if (direction_copy == DIO_PIN_OUTPUT)
 11a:	89 83       	std	Y+1, r24	; 0x01
 11c:	89 81       	ldd	r24, Y+1	; 0x01
 11e:	27 96       	adiw	r28, 0x07	; 7
 120:	0f b6       	in	r0, 0x3f	; 63
		{
					switch (port_copy)
 122:	f8 94       	cli
 124:	de bf       	out	0x3e, r29	; 62
 126:	0f be       	out	0x3f, r0	; 63
 128:	cd bf       	out	0x3d, r28	; 61
 12a:	cf 91       	pop	r28
 12c:	df 91       	pop	r29
 12e:	08 95       	ret

SWITCH_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000005f4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000a72  00000000  00000000  00000628  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.Switch_Status 000002a4  00000000  00000000  0000109a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.Switch_Status:

00000000 <Switch_Status>:
#define SWITCH_IS_PRESSED	  0
#define SWITCH_NOT_PRESSED	  1


u8 Switch_Status (u8 port_copy , u8 pin_copy , u8 type , u8* switch_statues )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a3 97       	sbiw	r28, 0x23	; 35
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8f 8f       	std	Y+31, r24	; 0x1f
  16:	68 a3       	std	Y+32, r22	; 0x20
  18:	49 a3       	std	Y+33, r20	; 0x21
  1a:	3b a3       	std	Y+35, r19	; 0x23
  1c:	2a a3       	std	Y+34, r18	; 0x22
	u8 Local_Error_Status = FUNCTION_IS_OK ;
  1e:	1e 8e       	std	Y+30, r1	; 0x1e
	u8 Ret_Val = 0 ;
  20:	1d 8e       	std	Y+29, r1	; 0x1d
	if(type == PULL_UP_SWITCH)
  22:	89 a1       	ldd	r24, Y+33	; 0x21
  24:	88 23       	and	r24, r24
  26:	01 f0       	breq	.+0      	; 0x28 <Switch_Status+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <Switch_Status+0x2a>
	{
		if(pin_copy<=DIO_PIN_7)
  2a:	88 a1       	ldd	r24, Y+32	; 0x20
  2c:	88 30       	cpi	r24, 0x08	; 8
  2e:	00 f0       	brcs	.+0      	; 0x30 <Switch_Status+0x30>
  30:	00 c0       	rjmp	.+0      	; 0x32 <Switch_Status+0x32>
		{
			Ret_Val =  GET_BIT(port_copy, pin_copy) ;
  32:	8f 8d       	ldd	r24, Y+31	; 0x1f
  34:	28 2f       	mov	r18, r24
  36:	30 e0       	ldi	r19, 0x00	; 0
  38:	88 a1       	ldd	r24, Y+32	; 0x20
  3a:	88 2f       	mov	r24, r24
  3c:	90 e0       	ldi	r25, 0x00	; 0
  3e:	a9 01       	movw	r20, r18
  40:	00 c0       	rjmp	.+0      	; 0x42 <Switch_Status+0x42>
  42:	55 95       	asr	r21
  44:	47 95       	ror	r20
  46:	8a 95       	dec	r24
  48:	02 f4       	brpl	.+0      	; 0x4a <Switch_Status+0x4a>
  4a:	ca 01       	movw	r24, r20
  4c:	81 70       	andi	r24, 0x01	; 1
  4e:	8d 8f       	std	Y+29, r24	; 0x1d
			if(Ret_Val == 0)
  50:	8d 8d       	ldd	r24, Y+29	; 0x1d
  52:	88 23       	and	r24, r24
  54:	01 f0       	breq	.+0      	; 0x56 <Switch_Status+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <Switch_Status+0x58>
  58:	80 e0       	ldi	r24, 0x00	; 0
  5a:	90 e0       	ldi	r25, 0x00	; 0
  5c:	a8 e4       	ldi	r26, 0x48	; 72
  5e:	b2 e4       	ldi	r27, 0x42	; 66
  60:	89 8f       	std	Y+25, r24	; 0x19
  62:	9a 8f       	std	Y+26, r25	; 0x1a
  64:	ab 8f       	std	Y+27, r26	; 0x1b
  66:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  68:	69 8d       	ldd	r22, Y+25	; 0x19
  6a:	7a 8d       	ldd	r23, Y+26	; 0x1a
  6c:	8b 8d       	ldd	r24, Y+27	; 0x1b
  6e:	9c 8d       	ldd	r25, Y+28	; 0x1c
  70:	20 e0       	ldi	r18, 0x00	; 0
  72:	30 e0       	ldi	r19, 0x00	; 0
  74:	4a e7       	ldi	r20, 0x7A	; 122
  76:	53 e4       	ldi	r21, 0x43	; 67
  78:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
  7c:	dc 01       	movw	r26, r24
  7e:	cb 01       	movw	r24, r22
  80:	8d 8b       	std	Y+21, r24	; 0x15
  82:	9e 8b       	std	Y+22, r25	; 0x16
  84:	af 8b       	std	Y+23, r26	; 0x17
  86:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
  88:	6d 89       	ldd	r22, Y+21	; 0x15
  8a:	7e 89       	ldd	r23, Y+22	; 0x16
  8c:	8f 89       	ldd	r24, Y+23	; 0x17
  8e:	98 8d       	ldd	r25, Y+24	; 0x18
  90:	20 e0       	ldi	r18, 0x00	; 0
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	40 e8       	ldi	r20, 0x80	; 128
  96:	5f e3       	ldi	r21, 0x3F	; 63
  98:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
  9c:	88 23       	and	r24, r24
  9e:	04 f4       	brge	.+0      	; 0xa0 <Switch_Status+0xa0>
		__ticks = 1;
  a0:	81 e0       	ldi	r24, 0x01	; 1
  a2:	90 e0       	ldi	r25, 0x00	; 0
  a4:	9c 8b       	std	Y+20, r25	; 0x14
  a6:	8b 8b       	std	Y+19, r24	; 0x13
  a8:	00 c0       	rjmp	.+0      	; 0xaa <Switch_Status+0xaa>
	else if (__tmp > 65535)
  aa:	6d 89       	ldd	r22, Y+21	; 0x15
  ac:	7e 89       	ldd	r23, Y+22	; 0x16
  ae:	8f 89       	ldd	r24, Y+23	; 0x17
  b0:	98 8d       	ldd	r25, Y+24	; 0x18
  b2:	20 e0       	ldi	r18, 0x00	; 0
  b4:	3f ef       	ldi	r19, 0xFF	; 255
  b6:	4f e7       	ldi	r20, 0x7F	; 127
  b8:	57 e4       	ldi	r21, 0x47	; 71
  ba:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
  be:	18 16       	cp	r1, r24
  c0:	04 f4       	brge	.+0      	; 0xc2 <Switch_Status+0xc2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  c2:	69 8d       	ldd	r22, Y+25	; 0x19
  c4:	7a 8d       	ldd	r23, Y+26	; 0x1a
  c6:	8b 8d       	ldd	r24, Y+27	; 0x1b
  c8:	9c 8d       	ldd	r25, Y+28	; 0x1c
  ca:	20 e0       	ldi	r18, 0x00	; 0
  cc:	30 e0       	ldi	r19, 0x00	; 0
  ce:	40 e2       	ldi	r20, 0x20	; 32
  d0:	51 e4       	ldi	r21, 0x41	; 65
  d2:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
  d6:	dc 01       	movw	r26, r24
  d8:	cb 01       	movw	r24, r22
  da:	bc 01       	movw	r22, r24
  dc:	cd 01       	movw	r24, r26
  de:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
  e2:	dc 01       	movw	r26, r24
  e4:	cb 01       	movw	r24, r22
  e6:	9c 8b       	std	Y+20, r25	; 0x14
  e8:	8b 8b       	std	Y+19, r24	; 0x13
  ea:	00 c0       	rjmp	.+0      	; 0xec <Switch_Status+0xec>
  ec:	89 e1       	ldi	r24, 0x19	; 25
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	9a 8b       	std	Y+18, r25	; 0x12
  f2:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  f4:	89 89       	ldd	r24, Y+17	; 0x11
  f6:	9a 89       	ldd	r25, Y+18	; 0x12
  f8:	01 97       	sbiw	r24, 0x01	; 1
  fa:	01 f4       	brne	.+0      	; 0xfc <Switch_Status+0xfc>
  fc:	9a 8b       	std	Y+18, r25	; 0x12
  fe:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 100:	8b 89       	ldd	r24, Y+19	; 0x13
 102:	9c 89       	ldd	r25, Y+20	; 0x14
 104:	01 97       	sbiw	r24, 0x01	; 1
 106:	9c 8b       	std	Y+20, r25	; 0x14
 108:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 10a:	8b 89       	ldd	r24, Y+19	; 0x13
 10c:	9c 89       	ldd	r25, Y+20	; 0x14
 10e:	00 97       	sbiw	r24, 0x00	; 0
 110:	01 f4       	brne	.+0      	; 0x112 <Switch_Status+0x112>
 112:	00 c0       	rjmp	.+0      	; 0x114 <Switch_Status+0x114>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 114:	6d 89       	ldd	r22, Y+21	; 0x15
 116:	7e 89       	ldd	r23, Y+22	; 0x16
 118:	8f 89       	ldd	r24, Y+23	; 0x17
 11a:	98 8d       	ldd	r25, Y+24	; 0x18
 11c:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
 120:	dc 01       	movw	r26, r24
 122:	cb 01       	movw	r24, r22
 124:	9c 8b       	std	Y+20, r25	; 0x14
 126:	8b 8b       	std	Y+19, r24	; 0x13
 128:	8b 89       	ldd	r24, Y+19	; 0x13
 12a:	9c 89       	ldd	r25, Y+20	; 0x14
 12c:	98 8b       	std	Y+16, r25	; 0x10
 12e:	8f 87       	std	Y+15, r24	; 0x0f
 130:	8f 85       	ldd	r24, Y+15	; 0x0f
 132:	98 89       	ldd	r25, Y+16	; 0x10
 134:	01 97       	sbiw	r24, 0x01	; 1
 136:	01 f4       	brne	.+0      	; 0x138 <Switch_Status+0x138>
 138:	98 8b       	std	Y+16, r25	; 0x10
 13a:	8f 87       	std	Y+15, r24	; 0x0f
			{
				_delay_ms(50);
				if(Ret_Val == 0)
 13c:	8d 8d       	ldd	r24, Y+29	; 0x1d
 13e:	88 23       	and	r24, r24
 140:	01 f4       	brne	.+0      	; 0x142 <Switch_Status+0x142>
				{
					*switch_statues = SWITCH_IS_PRESSED;
 142:	ea a1       	ldd	r30, Y+34	; 0x22
 144:	fb a1       	ldd	r31, Y+35	; 0x23
 146:	10 82       	st	Z, r1
 148:	00 c0       	rjmp	.+0      	; 0x14a <Switch_Status+0x14a>
				}
				else
				{
					*switch_statues = SWITCH_NOT_PRESSED;
 14a:	ea a1       	ldd	r30, Y+34	; 0x22
 14c:	fb a1       	ldd	r31, Y+35	; 0x23
 14e:	81 e0       	ldi	r24, 0x01	; 1
 150:	80 83       	st	Z, r24
 152:	00 c0       	rjmp	.+0      	; 0x154 <Switch_Status+0x154>
				}
			}
		}
		else
		{
			Local_Error_Status = FUNCTION_NOT_OK ;
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	8e 8f       	std	Y+30, r24	; 0x1e
 158:	00 c0       	rjmp	.+0      	; 0x15a <Switch_Status+0x15a>
		}
	}
	else if(type == PULL_DOWN_SWITCH)
 15a:	89 a1       	ldd	r24, Y+33	; 0x21
 15c:	81 30       	cpi	r24, 0x01	; 1
 15e:	01 f0       	breq	.+0      	; 0x160 <Switch_Status+0x160>
 160:	00 c0       	rjmp	.+0      	; 0x162 <Switch_Status+0x162>
		{
			if(pin_copy<=DIO_PIN_7)
 162:	88 a1       	ldd	r24, Y+32	; 0x20
 164:	88 30       	cpi	r24, 0x08	; 8
 166:	00 f0       	brcs	.+0      	; 0x168 <Switch_Status+0x168>
 168:	00 c0       	rjmp	.+0      	; 0x16a <Switch_Status+0x16a>
			{
				Ret_Val =  GET_BIT(port_copy, pin_copy) ;
 16a:	8f 8d       	ldd	r24, Y+31	; 0x1f
 16c:	28 2f       	mov	r18, r24
 16e:	30 e0       	ldi	r19, 0x00	; 0
 170:	88 a1       	ldd	r24, Y+32	; 0x20
 172:	88 2f       	mov	r24, r24
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	a9 01       	movw	r20, r18
 178:	00 c0       	rjmp	.+0      	; 0x17a <Switch_Status+0x17a>
 17a:	55 95       	asr	r21
 17c:	47 95       	ror	r20
 17e:	8a 95       	dec	r24
 180:	02 f4       	brpl	.+0      	; 0x182 <Switch_Status+0x182>
 182:	ca 01       	movw	r24, r20
 184:	81 70       	andi	r24, 0x01	; 1
 186:	8d 8f       	std	Y+29, r24	; 0x1d
				if(Ret_Val == 1)
 188:	8d 8d       	ldd	r24, Y+29	; 0x1d
 18a:	81 30       	cpi	r24, 0x01	; 1
 18c:	01 f0       	breq	.+0      	; 0x18e <Switch_Status+0x18e>
 18e:	00 c0       	rjmp	.+0      	; 0x190 <Switch_Status+0x190>
 190:	80 e0       	ldi	r24, 0x00	; 0
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	a8 e4       	ldi	r26, 0x48	; 72
 196:	b2 e4       	ldi	r27, 0x42	; 66
 198:	8b 87       	std	Y+11, r24	; 0x0b
 19a:	9c 87       	std	Y+12, r25	; 0x0c
 19c:	ad 87       	std	Y+13, r26	; 0x0d
 19e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 1a0:	6b 85       	ldd	r22, Y+11	; 0x0b
 1a2:	7c 85       	ldd	r23, Y+12	; 0x0c
 1a4:	8d 85       	ldd	r24, Y+13	; 0x0d
 1a6:	9e 85       	ldd	r25, Y+14	; 0x0e
 1a8:	20 e0       	ldi	r18, 0x00	; 0
 1aa:	30 e0       	ldi	r19, 0x00	; 0
 1ac:	4a e7       	ldi	r20, 0x7A	; 122
 1ae:	53 e4       	ldi	r21, 0x43	; 67
 1b0:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
 1b4:	dc 01       	movw	r26, r24
 1b6:	cb 01       	movw	r24, r22
 1b8:	8f 83       	std	Y+7, r24	; 0x07
 1ba:	98 87       	std	Y+8, r25	; 0x08
 1bc:	a9 87       	std	Y+9, r26	; 0x09
 1be:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
 1c0:	6f 81       	ldd	r22, Y+7	; 0x07
 1c2:	78 85       	ldd	r23, Y+8	; 0x08
 1c4:	89 85       	ldd	r24, Y+9	; 0x09
 1c6:	9a 85       	ldd	r25, Y+10	; 0x0a
 1c8:	20 e0       	ldi	r18, 0x00	; 0
 1ca:	30 e0       	ldi	r19, 0x00	; 0
 1cc:	40 e8       	ldi	r20, 0x80	; 128
 1ce:	5f e3       	ldi	r21, 0x3F	; 63
 1d0:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
 1d4:	88 23       	and	r24, r24
 1d6:	04 f4       	brge	.+0      	; 0x1d8 <Switch_Status+0x1d8>
		__ticks = 1;
 1d8:	81 e0       	ldi	r24, 0x01	; 1
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	9e 83       	std	Y+6, r25	; 0x06
 1de:	8d 83       	std	Y+5, r24	; 0x05
 1e0:	00 c0       	rjmp	.+0      	; 0x1e2 <Switch_Status+0x1e2>
	else if (__tmp > 65535)
 1e2:	6f 81       	ldd	r22, Y+7	; 0x07
 1e4:	78 85       	ldd	r23, Y+8	; 0x08
 1e6:	89 85       	ldd	r24, Y+9	; 0x09
 1e8:	9a 85       	ldd	r25, Y+10	; 0x0a
 1ea:	20 e0       	ldi	r18, 0x00	; 0
 1ec:	3f ef       	ldi	r19, 0xFF	; 255
 1ee:	4f e7       	ldi	r20, 0x7F	; 127
 1f0:	57 e4       	ldi	r21, 0x47	; 71
 1f2:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
 1f6:	18 16       	cp	r1, r24
 1f8:	04 f4       	brge	.+0      	; 0x1fa <Switch_Status+0x1fa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 1fa:	6b 85       	ldd	r22, Y+11	; 0x0b
 1fc:	7c 85       	ldd	r23, Y+12	; 0x0c
 1fe:	8d 85       	ldd	r24, Y+13	; 0x0d
 200:	9e 85       	ldd	r25, Y+14	; 0x0e
 202:	20 e0       	ldi	r18, 0x00	; 0
 204:	30 e0       	ldi	r19, 0x00	; 0
 206:	40 e2       	ldi	r20, 0x20	; 32
 208:	51 e4       	ldi	r21, 0x41	; 65
 20a:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
 20e:	dc 01       	movw	r26, r24
 210:	cb 01       	movw	r24, r22
 212:	bc 01       	movw	r22, r24
 214:	cd 01       	movw	r24, r26
 216:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
 21a:	dc 01       	movw	r26, r24
 21c:	cb 01       	movw	r24, r22
 21e:	9e 83       	std	Y+6, r25	; 0x06
 220:	8d 83       	std	Y+5, r24	; 0x05
 222:	00 c0       	rjmp	.+0      	; 0x224 <Switch_Status+0x224>
 224:	89 e1       	ldi	r24, 0x19	; 25
 226:	90 e0       	ldi	r25, 0x00	; 0
 228:	9c 83       	std	Y+4, r25	; 0x04
 22a:	8b 83       	std	Y+3, r24	; 0x03
 22c:	8b 81       	ldd	r24, Y+3	; 0x03
 22e:	9c 81       	ldd	r25, Y+4	; 0x04
 230:	01 97       	sbiw	r24, 0x01	; 1
 232:	01 f4       	brne	.+0      	; 0x234 <Switch_Status+0x234>
 234:	9c 83       	std	Y+4, r25	; 0x04
 236:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 238:	8d 81       	ldd	r24, Y+5	; 0x05
 23a:	9e 81       	ldd	r25, Y+6	; 0x06
 23c:	01 97       	sbiw	r24, 0x01	; 1
 23e:	9e 83       	std	Y+6, r25	; 0x06
 240:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 242:	8d 81       	ldd	r24, Y+5	; 0x05
 244:	9e 81       	ldd	r25, Y+6	; 0x06
 246:	00 97       	sbiw	r24, 0x00	; 0
 248:	01 f4       	brne	.+0      	; 0x24a <Switch_Status+0x24a>
 24a:	00 c0       	rjmp	.+0      	; 0x24c <Switch_Status+0x24c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 24c:	6f 81       	ldd	r22, Y+7	; 0x07
 24e:	78 85       	ldd	r23, Y+8	; 0x08
 250:	89 85       	ldd	r24, Y+9	; 0x09
 252:	9a 85       	ldd	r25, Y+10	; 0x0a
 254:	0e 94 00 00 	call	0	; 0x0 <Switch_Status>
 258:	dc 01       	movw	r26, r24
 25a:	cb 01       	movw	r24, r22
 25c:	9e 83       	std	Y+6, r25	; 0x06
 25e:	8d 83       	std	Y+5, r24	; 0x05
 260:	8d 81       	ldd	r24, Y+5	; 0x05
 262:	9e 81       	ldd	r25, Y+6	; 0x06
 264:	9a 83       	std	Y+2, r25	; 0x02
 266:	89 83       	std	Y+1, r24	; 0x01
 268:	89 81       	ldd	r24, Y+1	; 0x01
 26a:	9a 81       	ldd	r25, Y+2	; 0x02
 26c:	01 97       	sbiw	r24, 0x01	; 1
 26e:	01 f4       	brne	.+0      	; 0x270 <Switch_Status+0x270>
 270:	9a 83       	std	Y+2, r25	; 0x02
 272:	89 83       	std	Y+1, r24	; 0x01
				{
					_delay_ms(50);
					if(Ret_Val == 1)
 274:	8d 8d       	ldd	r24, Y+29	; 0x1d
 276:	81 30       	cpi	r24, 0x01	; 1
 278:	01 f4       	brne	.+0      	; 0x27a <Switch_Status+0x27a>
					{
					*switch_statues = SWITCH_IS_PRESSED;
 27a:	ea a1       	ldd	r30, Y+34	; 0x22
 27c:	fb a1       	ldd	r31, Y+35	; 0x23
 27e:	10 82       	st	Z, r1
 280:	00 c0       	rjmp	.+0      	; 0x282 <Switch_Status+0x282>
					}
					else
					{
						*switch_statues = SWITCH_NOT_PRESSED;
 282:	ea a1       	ldd	r30, Y+34	; 0x22
 284:	fb a1       	ldd	r31, Y+35	; 0x23
 286:	81 e0       	ldi	r24, 0x01	; 1
 288:	80 83       	st	Z, r24
 28a:	00 c0       	rjmp	.+0      	; 0x28c <Switch_Status+0x28c>
					}
				}
			}
			else
			{
				Local_Error_Status = FUNCTION_NOT_OK ;
 28c:	81 e0       	ldi	r24, 0x01	; 1
 28e:	8e 8f       	std	Y+30, r24	; 0x1e
			}
		}

	return Local_Error_Status;
 290:	8e 8d       	ldd	r24, Y+30	; 0x1e
}
 292:	a3 96       	adiw	r28, 0x23	; 35
 294:	0f b6       	in	r0, 0x3f	; 63
 296:	f8 94       	cli
 298:	de bf       	out	0x3e, r29	; 62
 29a:	0f be       	out	0x3f, r0	; 63
 29c:	cd bf       	out	0x3d, r28	; 61
 29e:	cf 91       	pop	r28
 2a0:	df 91       	pop	r29
 2a2:	08 95       	ret

SEVEN_SEG_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         0000087c  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000c03  00000000  00000000  000008b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .data.seven_seg_arr_anode 0000000a  00000000  00000000  000014b3  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .text.Seven_Seg_Init 0000008a  00000000  00000000  000014bd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.Seven_Seg_TurnON 00000062  00000000  00000000  00001547  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.Seven_Seg_TurnOff 00000044  00000000  00000000  000015a9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.Seven_Seg_CountUp 00000140  00000000  00000000  000015ed  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.Seven_Seg_Countdown 00000140  00000000  00000000  0000172d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.Seven_Seg_Init:

00000000 <Seven_Seg_Init>:
			0b01111111, // 8
			0b01101111  // 9
    };

u8 Seven_Seg_Init (u8 port_copy)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Seven_Seg_Init+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <Seven_Seg_Init+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_Error_Status = FUNCTION_IS_OK ;
   e:	19 82       	std	Y+1, r1	; 0x01

		switch(port_copy)
  10:	8a 81       	ldd	r24, Y+2	; 0x02
  12:	28 2f       	mov	r18, r24
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	81 30       	cpi	r24, 0x01	; 1
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <Seven_Seg_Init+0x24>
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	22 30       	cpi	r18, 0x02	; 2
  2a:	31 05       	cpc	r19, r1
  2c:	04 f4       	brge	.+0      	; 0x2e <Seven_Seg_Init+0x2e>
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <Seven_Seg_Init+0x36>
  36:	00 c0       	rjmp	.+0      	; 0x38 <Seven_Seg_Init+0x38>
  38:	2b 81       	ldd	r18, Y+3	; 0x03
  3a:	3c 81       	ldd	r19, Y+4	; 0x04
  3c:	22 30       	cpi	r18, 0x02	; 2
  3e:	31 05       	cpc	r19, r1
  40:	01 f0       	breq	.+0      	; 0x42 <Seven_Seg_Init+0x42>
  42:	8b 81       	ldd	r24, Y+3	; 0x03
  44:	9c 81       	ldd	r25, Y+4	; 0x04
  46:	83 30       	cpi	r24, 0x03	; 3
  48:	91 05       	cpc	r25, r1
  4a:	01 f0       	breq	.+0      	; 0x4c <Seven_Seg_Init+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <Seven_Seg_Init+0x4e>
			{
				case DIO_PORT_A: DDR_A = 0xff ;	    break ;
  4e:	ea e3       	ldi	r30, 0x3A	; 58
  50:	f0 e0       	ldi	r31, 0x00	; 0
  52:	8f ef       	ldi	r24, 0xFF	; 255
  54:	80 83       	st	Z, r24
  56:	00 c0       	rjmp	.+0      	; 0x58 <Seven_Seg_Init+0x58>
				case DIO_PORT_B: DDR_B = 0xff ;     break ;
  58:	e7 e3       	ldi	r30, 0x37	; 55
  5a:	f0 e0       	ldi	r31, 0x00	; 0
  5c:	8f ef       	ldi	r24, 0xFF	; 255
  5e:	80 83       	st	Z, r24
  60:	00 c0       	rjmp	.+0      	; 0x62 <Seven_Seg_Init+0x62>
				case DIO_PORT_C: DDR_C = 0xff ; 	break ;
  62:	e4 e3       	ldi	r30, 0x34	; 52
  64:	f0 e0       	ldi	r31, 0x00	; 0
  66:	8f ef       	ldi	r24, 0xFF	; 255
  68:	80 83       	st	Z, r24
  6a:	00 c0       	rjmp	.+0      	; 0x6c <Seven_Seg_Init+0x6c>
				case DIO_PORT_D: DDR_D = 0xff ; 	break ;
  6c:	e1 e3       	ldi	r30, 0x31	; 49
  6e:	f0 e0       	ldi	r31, 0x00	; 0
  70:	8f ef       	ldi	r24, 0xFF	; 255
  72:	80 83       	st	Z, r24
  74:	00 c0       	rjmp	.+0      	; 0x76 <Seven_Seg_Init+0x76>
				default : Local_Error_Status = FUNCTION_NOT_OK ;
  76:	81 e0       	ldi	r24, 0x01	; 1
  78:	89 83       	std	Y+1, r24	; 0x01
			}

	return Local_Error_Status;
  7a:	89 81       	ldd	r24, Y+1	; 0x01
}
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	cf 91       	pop	r28
  86:	df 91       	pop	r29
  88:	08 95       	ret

Disassembly of section .text.Seven_Seg_TurnON:

00000000 <Seven_Seg_TurnON>:
			0b01111111, // 8
			0b01101111  // 9
    };

u8 Seven_Seg_Init (u8 port_copy)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Seven_Seg_TurnON+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <Seven_Seg_TurnON+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_Error_Status = FUNCTION_IS_OK ;
   e:	6b 83       	std	Y+3, r22	; 0x03

		switch(port_copy)
  10:	4c 83       	std	Y+4, r20	; 0x04
  12:	19 82       	std	Y+1, r1	; 0x01
  14:	8b 81       	ldd	r24, Y+3	; 0x03
  16:	8a 30       	cpi	r24, 0x0A	; 10
  18:	00 f4       	brcc	.+0      	; 0x1a <Seven_Seg_TurnON+0x1a>
  1a:	8c 81       	ldd	r24, Y+4	; 0x04
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	01 f4       	brne	.+0      	; 0x20 <Seven_Seg_TurnON+0x20>
  20:	8b 81       	ldd	r24, Y+3	; 0x03
  22:	88 2f       	mov	r24, r24
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	fc 01       	movw	r30, r24
  28:	e0 50       	subi	r30, 0x00	; 0
  2a:	f0 40       	sbci	r31, 0x00	; 0
  2c:	90 81       	ld	r25, Z
  2e:	8a 81       	ldd	r24, Y+2	; 0x02
  30:	69 2f       	mov	r22, r25
  32:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_TurnON>
  36:	00 c0       	rjmp	.+0      	; 0x38 <Seven_Seg_TurnON+0x38>
  38:	8b 81       	ldd	r24, Y+3	; 0x03
  3a:	88 2f       	mov	r24, r24
  3c:	90 e0       	ldi	r25, 0x00	; 0
  3e:	fc 01       	movw	r30, r24
  40:	e0 50       	subi	r30, 0x00	; 0
  42:	f0 40       	sbci	r31, 0x00	; 0
  44:	80 81       	ld	r24, Z
  46:	98 2f       	mov	r25, r24
  48:	90 95       	com	r25
  4a:	8a 81       	ldd	r24, Y+2	; 0x02
  4c:	69 2f       	mov	r22, r25
			{
				case DIO_PORT_A: DDR_A = 0xff ;	    break ;
  4e:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_TurnON>
  52:	89 81       	ldd	r24, Y+1	; 0x01
  54:	0f 90       	pop	r0
  56:	0f 90       	pop	r0
				case DIO_PORT_B: DDR_B = 0xff ;     break ;
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	cf 91       	pop	r28
  5e:	df 91       	pop	r29
  60:	08 95       	ret

Disassembly of section .text.Seven_Seg_TurnOff:

00000000 <Seven_Seg_TurnOff>:
			0b01111111, // 8
			0b01101111  // 9
    };

u8 Seven_Seg_Init (u8 port_copy)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <Seven_Seg_TurnOff+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_Error_Status = FUNCTION_IS_OK ;
   e:	6b 83       	std	Y+3, r22	; 0x03

		switch(port_copy)
  10:	19 82       	std	Y+1, r1	; 0x01
  12:	8b 81       	ldd	r24, Y+3	; 0x03
  14:	81 30       	cpi	r24, 0x01	; 1
  16:	01 f4       	brne	.+0      	; 0x18 <Seven_Seg_TurnOff+0x18>
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	6f ef       	ldi	r22, 0xFF	; 255
  1c:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_TurnOff>
  20:	00 c0       	rjmp	.+0      	; 0x22 <Seven_Seg_TurnOff+0x22>
  22:	8b 81       	ldd	r24, Y+3	; 0x03
  24:	82 30       	cpi	r24, 0x02	; 2
  26:	01 f4       	brne	.+0      	; 0x28 <Seven_Seg_TurnOff+0x28>
  28:	8a 81       	ldd	r24, Y+2	; 0x02
  2a:	60 e0       	ldi	r22, 0x00	; 0
  2c:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_TurnOff>
  30:	00 c0       	rjmp	.+0      	; 0x32 <Seven_Seg_TurnOff+0x32>
  32:	81 e0       	ldi	r24, 0x01	; 1
  34:	89 83       	std	Y+1, r24	; 0x01
  36:	89 81       	ldd	r24, Y+1	; 0x01
  38:	0f 90       	pop	r0
  3a:	0f 90       	pop	r0
  3c:	0f 90       	pop	r0
  3e:	cf 91       	pop	r28
  40:	df 91       	pop	r29
  42:	08 95       	ret

Disassembly of section .text.Seven_Seg_CountUp:

00000000 <Seven_Seg_CountUp>:
			0b01111111, // 8
			0b01101111  // 9
    };

u8 Seven_Seg_Init (u8 port_copy)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	63 97       	sbiw	r28, 0x13	; 19
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
	u8 Local_Error_Status = FUNCTION_IS_OK ;
   e:	de bf       	out	0x3e, r29	; 62

		switch(port_copy)
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 8b       	std	Y+17, r24	; 0x11
  16:	6a 8b       	std	Y+18, r22	; 0x12
  18:	4b 8b       	std	Y+19, r20	; 0x13
  1a:	18 8a       	std	Y+16, r1	; 0x10
  1c:	8a 89       	ldd	r24, Y+18	; 0x12
  1e:	8a 30       	cpi	r24, 0x0A	; 10
  20:	00 f0       	brcs	.+0      	; 0x22 <Seven_Seg_CountUp+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <Seven_Seg_CountUp+0x24>
  24:	8a 89       	ldd	r24, Y+18	; 0x12
  26:	8f 87       	std	Y+15, r24	; 0x0f
  28:	00 c0       	rjmp	.+0      	; 0x2a <Seven_Seg_CountUp+0x2a>
  2a:	89 89       	ldd	r24, Y+17	; 0x11
  2c:	6a 89       	ldd	r22, Y+18	; 0x12
  2e:	4b 89       	ldd	r20, Y+19	; 0x13
  30:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_CountUp>
  34:	80 e0       	ldi	r24, 0x00	; 0
  36:	90 e0       	ldi	r25, 0x00	; 0
  38:	aa ef       	ldi	r26, 0xFA	; 250
  3a:	b3 e4       	ldi	r27, 0x43	; 67
  3c:	8b 87       	std	Y+11, r24	; 0x0b
  3e:	9c 87       	std	Y+12, r25	; 0x0c
  40:	ad 87       	std	Y+13, r26	; 0x0d
  42:	be 87       	std	Y+14, r27	; 0x0e
  44:	6b 85       	ldd	r22, Y+11	; 0x0b
  46:	7c 85       	ldd	r23, Y+12	; 0x0c
  48:	8d 85       	ldd	r24, Y+13	; 0x0d
  4a:	9e 85       	ldd	r25, Y+14	; 0x0e
  4c:	20 e0       	ldi	r18, 0x00	; 0
			{
				case DIO_PORT_A: DDR_A = 0xff ;	    break ;
  4e:	30 e0       	ldi	r19, 0x00	; 0
  50:	4a e7       	ldi	r20, 0x7A	; 122
  52:	53 e4       	ldi	r21, 0x43	; 67
  54:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_CountUp>
				case DIO_PORT_B: DDR_B = 0xff ;     break ;
  58:	dc 01       	movw	r26, r24
  5a:	cb 01       	movw	r24, r22
  5c:	8f 83       	std	Y+7, r24	; 0x07
  5e:	98 87       	std	Y+8, r25	; 0x08
  60:	a9 87       	std	Y+9, r26	; 0x09
				case DIO_PORT_C: DDR_C = 0xff ; 	break ;
  62:	ba 87       	std	Y+10, r27	; 0x0a
  64:	6f 81       	ldd	r22, Y+7	; 0x07
  66:	78 85       	ldd	r23, Y+8	; 0x08
  68:	89 85       	ldd	r24, Y+9	; 0x09
  6a:	9a 85       	ldd	r25, Y+10	; 0x0a
				case DIO_PORT_D: DDR_D = 0xff ; 	break ;
  6c:	20 e0       	ldi	r18, 0x00	; 0
  6e:	30 e0       	ldi	r19, 0x00	; 0
  70:	40 e8       	ldi	r20, 0x80	; 128
  72:	5f e3       	ldi	r21, 0x3F	; 63
  74:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_CountUp>
				default : Local_Error_Status = FUNCTION_NOT_OK ;
  78:	88 23       	and	r24, r24
			}

	return Local_Error_Status;
  7a:	04 f4       	brge	.+0      	; 0x7c <Seven_Seg_CountUp+0x7c>
}
  7c:	81 e0       	ldi	r24, 0x01	; 1
  7e:	90 e0       	ldi	r25, 0x00	; 0
  80:	9e 83       	std	Y+6, r25	; 0x06
  82:	8d 83       	std	Y+5, r24	; 0x05
  84:	00 c0       	rjmp	.+0      	; 0x86 <Seven_Seg_CountUp+0x86>
  86:	6f 81       	ldd	r22, Y+7	; 0x07
  88:	78 85       	ldd	r23, Y+8	; 0x08
  8a:	89 85       	ldd	r24, Y+9	; 0x09
  8c:	9a 85       	ldd	r25, Y+10	; 0x0a
  8e:	20 e0       	ldi	r18, 0x00	; 0
  90:	3f ef       	ldi	r19, 0xFF	; 255
  92:	4f e7       	ldi	r20, 0x7F	; 127
  94:	57 e4       	ldi	r21, 0x47	; 71
  96:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_CountUp>
  9a:	18 16       	cp	r1, r24
  9c:	04 f4       	brge	.+0      	; 0x9e <Seven_Seg_CountUp+0x9e>
  9e:	6b 85       	ldd	r22, Y+11	; 0x0b
  a0:	7c 85       	ldd	r23, Y+12	; 0x0c
  a2:	8d 85       	ldd	r24, Y+13	; 0x0d
  a4:	9e 85       	ldd	r25, Y+14	; 0x0e
  a6:	20 e0       	ldi	r18, 0x00	; 0
  a8:	30 e0       	ldi	r19, 0x00	; 0
  aa:	40 e2       	ldi	r20, 0x20	; 32
  ac:	51 e4       	ldi	r21, 0x41	; 65
  ae:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_CountUp>
  b2:	dc 01       	movw	r26, r24
  b4:	cb 01       	movw	r24, r22
  b6:	bc 01       	movw	r22, r24
  b8:	cd 01       	movw	r24, r26
  ba:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_CountUp>
  be:	dc 01       	movw	r26, r24
  c0:	cb 01       	movw	r24, r22
  c2:	9e 83       	std	Y+6, r25	; 0x06
  c4:	8d 83       	std	Y+5, r24	; 0x05
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <Seven_Seg_CountUp+0xc8>
  c8:	89 e1       	ldi	r24, 0x19	; 25
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	9c 83       	std	Y+4, r25	; 0x04
  ce:	8b 83       	std	Y+3, r24	; 0x03
  d0:	8b 81       	ldd	r24, Y+3	; 0x03
  d2:	9c 81       	ldd	r25, Y+4	; 0x04
  d4:	01 97       	sbiw	r24, 0x01	; 1
  d6:	01 f4       	brne	.+0      	; 0xd8 <Seven_Seg_CountUp+0xd8>
  d8:	9c 83       	std	Y+4, r25	; 0x04
  da:	8b 83       	std	Y+3, r24	; 0x03
  dc:	8d 81       	ldd	r24, Y+5	; 0x05
  de:	9e 81       	ldd	r25, Y+6	; 0x06
  e0:	01 97       	sbiw	r24, 0x01	; 1
  e2:	9e 83       	std	Y+6, r25	; 0x06
  e4:	8d 83       	std	Y+5, r24	; 0x05
  e6:	8d 81       	ldd	r24, Y+5	; 0x05
  e8:	9e 81       	ldd	r25, Y+6	; 0x06
  ea:	00 97       	sbiw	r24, 0x00	; 0
  ec:	01 f4       	brne	.+0      	; 0xee <Seven_Seg_CountUp+0xee>
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <Seven_Seg_CountUp+0xf0>
  f0:	6f 81       	ldd	r22, Y+7	; 0x07
  f2:	78 85       	ldd	r23, Y+8	; 0x08
  f4:	89 85       	ldd	r24, Y+9	; 0x09
  f6:	9a 85       	ldd	r25, Y+10	; 0x0a
  f8:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_CountUp>
  fc:	dc 01       	movw	r26, r24
  fe:	cb 01       	movw	r24, r22
 100:	9e 83       	std	Y+6, r25	; 0x06
 102:	8d 83       	std	Y+5, r24	; 0x05
 104:	8d 81       	ldd	r24, Y+5	; 0x05
 106:	9e 81       	ldd	r25, Y+6	; 0x06
 108:	9a 83       	std	Y+2, r25	; 0x02
 10a:	89 83       	std	Y+1, r24	; 0x01
 10c:	89 81       	ldd	r24, Y+1	; 0x01
 10e:	9a 81       	ldd	r25, Y+2	; 0x02
 110:	01 97       	sbiw	r24, 0x01	; 1
 112:	01 f4       	brne	.+0      	; 0x114 <Seven_Seg_CountUp+0x114>
 114:	9a 83       	std	Y+2, r25	; 0x02
 116:	89 83       	std	Y+1, r24	; 0x01
 118:	8f 85       	ldd	r24, Y+15	; 0x0f
 11a:	8f 5f       	subi	r24, 0xFF	; 255
 11c:	8f 87       	std	Y+15, r24	; 0x0f
 11e:	8f 85       	ldd	r24, Y+15	; 0x0f
 120:	8a 30       	cpi	r24, 0x0A	; 10
 122:	04 f4       	brge	.+0      	; 0x124 <Seven_Seg_CountUp+0x124>
 124:	00 c0       	rjmp	.+0      	; 0x126 <Seven_Seg_CountUp+0x126>
 126:	00 c0       	rjmp	.+0      	; 0x128 <Seven_Seg_CountUp+0x128>
 128:	81 e0       	ldi	r24, 0x01	; 1
 12a:	88 8b       	std	Y+16, r24	; 0x10
 12c:	88 89       	ldd	r24, Y+16	; 0x10
 12e:	63 96       	adiw	r28, 0x13	; 19
 130:	0f b6       	in	r0, 0x3f	; 63
 132:	f8 94       	cli
 134:	de bf       	out	0x3e, r29	; 62
 136:	0f be       	out	0x3f, r0	; 63
 138:	cd bf       	out	0x3d, r28	; 61
 13a:	cf 91       	pop	r28
 13c:	df 91       	pop	r29
 13e:	08 95       	ret

Disassembly of section .text.Seven_Seg_Countdown:

00000000 <Seven_Seg_Countdown>:
			0b01111111, // 8
			0b01101111  // 9
    };

u8 Seven_Seg_Init (u8 port_copy)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	63 97       	sbiw	r28, 0x13	; 19
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
	u8 Local_Error_Status = FUNCTION_IS_OK ;
   e:	de bf       	out	0x3e, r29	; 62

		switch(port_copy)
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 8b       	std	Y+17, r24	; 0x11
  16:	6a 8b       	std	Y+18, r22	; 0x12
  18:	4b 8b       	std	Y+19, r20	; 0x13
  1a:	18 8a       	std	Y+16, r1	; 0x10
  1c:	8a 89       	ldd	r24, Y+18	; 0x12
  1e:	8a 30       	cpi	r24, 0x0A	; 10
  20:	00 f0       	brcs	.+0      	; 0x22 <Seven_Seg_Countdown+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <Seven_Seg_Countdown+0x24>
  24:	8a 89       	ldd	r24, Y+18	; 0x12
  26:	8f 87       	std	Y+15, r24	; 0x0f
  28:	00 c0       	rjmp	.+0      	; 0x2a <Seven_Seg_Countdown+0x2a>
  2a:	89 89       	ldd	r24, Y+17	; 0x11
  2c:	6a 89       	ldd	r22, Y+18	; 0x12
  2e:	4b 89       	ldd	r20, Y+19	; 0x13
  30:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_Countdown>
  34:	80 e0       	ldi	r24, 0x00	; 0
  36:	90 e0       	ldi	r25, 0x00	; 0
  38:	aa ef       	ldi	r26, 0xFA	; 250
  3a:	b3 e4       	ldi	r27, 0x43	; 67
  3c:	8b 87       	std	Y+11, r24	; 0x0b
  3e:	9c 87       	std	Y+12, r25	; 0x0c
  40:	ad 87       	std	Y+13, r26	; 0x0d
  42:	be 87       	std	Y+14, r27	; 0x0e
  44:	6b 85       	ldd	r22, Y+11	; 0x0b
  46:	7c 85       	ldd	r23, Y+12	; 0x0c
  48:	8d 85       	ldd	r24, Y+13	; 0x0d
  4a:	9e 85       	ldd	r25, Y+14	; 0x0e
  4c:	20 e0       	ldi	r18, 0x00	; 0
			{
				case DIO_PORT_A: DDR_A = 0xff ;	    break ;
  4e:	30 e0       	ldi	r19, 0x00	; 0
  50:	4a e7       	ldi	r20, 0x7A	; 122
  52:	53 e4       	ldi	r21, 0x43	; 67
  54:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_Countdown>
				case DIO_PORT_B: DDR_B = 0xff ;     break ;
  58:	dc 01       	movw	r26, r24
  5a:	cb 01       	movw	r24, r22
  5c:	8f 83       	std	Y+7, r24	; 0x07
  5e:	98 87       	std	Y+8, r25	; 0x08
  60:	a9 87       	std	Y+9, r26	; 0x09
				case DIO_PORT_C: DDR_C = 0xff ; 	break ;
  62:	ba 87       	std	Y+10, r27	; 0x0a
  64:	6f 81       	ldd	r22, Y+7	; 0x07
  66:	78 85       	ldd	r23, Y+8	; 0x08
  68:	89 85       	ldd	r24, Y+9	; 0x09
  6a:	9a 85       	ldd	r25, Y+10	; 0x0a
				case DIO_PORT_D: DDR_D = 0xff ; 	break ;
  6c:	20 e0       	ldi	r18, 0x00	; 0
  6e:	30 e0       	ldi	r19, 0x00	; 0
  70:	40 e8       	ldi	r20, 0x80	; 128
  72:	5f e3       	ldi	r21, 0x3F	; 63
  74:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_Countdown>
				default : Local_Error_Status = FUNCTION_NOT_OK ;
  78:	88 23       	and	r24, r24
			}

	return Local_Error_Status;
  7a:	04 f4       	brge	.+0      	; 0x7c <Seven_Seg_Countdown+0x7c>
}
  7c:	81 e0       	ldi	r24, 0x01	; 1
  7e:	90 e0       	ldi	r25, 0x00	; 0
  80:	9e 83       	std	Y+6, r25	; 0x06
  82:	8d 83       	std	Y+5, r24	; 0x05
  84:	00 c0       	rjmp	.+0      	; 0x86 <Seven_Seg_Countdown+0x86>
  86:	6f 81       	ldd	r22, Y+7	; 0x07
  88:	78 85       	ldd	r23, Y+8	; 0x08
  8a:	89 85       	ldd	r24, Y+9	; 0x09
  8c:	9a 85       	ldd	r25, Y+10	; 0x0a
  8e:	20 e0       	ldi	r18, 0x00	; 0
  90:	3f ef       	ldi	r19, 0xFF	; 255
  92:	4f e7       	ldi	r20, 0x7F	; 127
  94:	57 e4       	ldi	r21, 0x47	; 71
  96:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_Countdown>
  9a:	18 16       	cp	r1, r24
  9c:	04 f4       	brge	.+0      	; 0x9e <Seven_Seg_Countdown+0x9e>
  9e:	6b 85       	ldd	r22, Y+11	; 0x0b
  a0:	7c 85       	ldd	r23, Y+12	; 0x0c
  a2:	8d 85       	ldd	r24, Y+13	; 0x0d
  a4:	9e 85       	ldd	r25, Y+14	; 0x0e
  a6:	20 e0       	ldi	r18, 0x00	; 0
  a8:	30 e0       	ldi	r19, 0x00	; 0
  aa:	40 e2       	ldi	r20, 0x20	; 32
  ac:	51 e4       	ldi	r21, 0x41	; 65
  ae:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_Countdown>
  b2:	dc 01       	movw	r26, r24
  b4:	cb 01       	movw	r24, r22
  b6:	bc 01       	movw	r22, r24
  b8:	cd 01       	movw	r24, r26
  ba:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_Countdown>
  be:	dc 01       	movw	r26, r24
  c0:	cb 01       	movw	r24, r22
  c2:	9e 83       	std	Y+6, r25	; 0x06
  c4:	8d 83       	std	Y+5, r24	; 0x05
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <Seven_Seg_Countdown+0xc8>
  c8:	89 e1       	ldi	r24, 0x19	; 25
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	9c 83       	std	Y+4, r25	; 0x04
  ce:	8b 83       	std	Y+3, r24	; 0x03
  d0:	8b 81       	ldd	r24, Y+3	; 0x03
  d2:	9c 81       	ldd	r25, Y+4	; 0x04
  d4:	01 97       	sbiw	r24, 0x01	; 1
  d6:	01 f4       	brne	.+0      	; 0xd8 <Seven_Seg_Countdown+0xd8>
  d8:	9c 83       	std	Y+4, r25	; 0x04
  da:	8b 83       	std	Y+3, r24	; 0x03
  dc:	8d 81       	ldd	r24, Y+5	; 0x05
  de:	9e 81       	ldd	r25, Y+6	; 0x06
  e0:	01 97       	sbiw	r24, 0x01	; 1
  e2:	9e 83       	std	Y+6, r25	; 0x06
  e4:	8d 83       	std	Y+5, r24	; 0x05
  e6:	8d 81       	ldd	r24, Y+5	; 0x05
  e8:	9e 81       	ldd	r25, Y+6	; 0x06
  ea:	00 97       	sbiw	r24, 0x00	; 0
  ec:	01 f4       	brne	.+0      	; 0xee <Seven_Seg_Countdown+0xee>
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <Seven_Seg_Countdown+0xf0>
  f0:	6f 81       	ldd	r22, Y+7	; 0x07
  f2:	78 85       	ldd	r23, Y+8	; 0x08
  f4:	89 85       	ldd	r24, Y+9	; 0x09
  f6:	9a 85       	ldd	r25, Y+10	; 0x0a
  f8:	0e 94 00 00 	call	0	; 0x0 <Seven_Seg_Countdown>
  fc:	dc 01       	movw	r26, r24
  fe:	cb 01       	movw	r24, r22
 100:	9e 83       	std	Y+6, r25	; 0x06
 102:	8d 83       	std	Y+5, r24	; 0x05
 104:	8d 81       	ldd	r24, Y+5	; 0x05
 106:	9e 81       	ldd	r25, Y+6	; 0x06
 108:	9a 83       	std	Y+2, r25	; 0x02
 10a:	89 83       	std	Y+1, r24	; 0x01
 10c:	89 81       	ldd	r24, Y+1	; 0x01
 10e:	9a 81       	ldd	r25, Y+2	; 0x02
 110:	01 97       	sbiw	r24, 0x01	; 1
 112:	01 f4       	brne	.+0      	; 0x114 <Seven_Seg_Countdown+0x114>
 114:	9a 83       	std	Y+2, r25	; 0x02
 116:	89 83       	std	Y+1, r24	; 0x01
 118:	8f 85       	ldd	r24, Y+15	; 0x0f
 11a:	81 50       	subi	r24, 0x01	; 1
 11c:	8f 87       	std	Y+15, r24	; 0x0f
 11e:	8f 85       	ldd	r24, Y+15	; 0x0f
 120:	88 23       	and	r24, r24
 122:	04 f0       	brlt	.+0      	; 0x124 <Seven_Seg_Countdown+0x124>
 124:	00 c0       	rjmp	.+0      	; 0x126 <Seven_Seg_Countdown+0x126>
 126:	00 c0       	rjmp	.+0      	; 0x128 <Seven_Seg_Countdown+0x128>
 128:	81 e0       	ldi	r24, 0x01	; 1
 12a:	88 8b       	std	Y+16, r24	; 0x10
 12c:	88 89       	ldd	r24, Y+16	; 0x10
 12e:	63 96       	adiw	r28, 0x13	; 19
 130:	0f b6       	in	r0, 0x3f	; 63
 132:	f8 94       	cli
 134:	de bf       	out	0x3e, r29	; 62
 136:	0f be       	out	0x3f, r0	; 63
 138:	cd bf       	out	0x3d, r28	; 61
 13a:	cf 91       	pop	r28
 13c:	df 91       	pop	r29
 13e:	08 95       	ret

LED_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         0000048c  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000042b  00000000  00000000  000004c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.LED_ON  00000116  00000000  00000000  000008eb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.LED_OFF 00000120  00000000  00000000  00000a01  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.LED_ALL_PORT_ON 0000008a  00000000  00000000  00000b21  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.LED_ALL_PORT_OFF 00000082  00000000  00000000  00000bab  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.LED_ON:

00000000 <LED_ON>:
#define NULL 				0
#define FUNCTION_IS_OK 		0
#define FUNCTION_NOT_OK 	1

u8 LED_ON (u8 copy_port , u8 copy_pin)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LED_ON+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LED_ON+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_Status_Error = FUNCTION_IS_OK ;
  12:	19 82       	std	Y+1, r1	; 0x01
	if(copy_pin<=DIO_PIN_7)
  14:	8b 81       	ldd	r24, Y+3	; 0x03
  16:	88 30       	cpi	r24, 0x08	; 8
  18:	00 f0       	brcs	.+0      	; 0x1a <LED_ON+0x1a>
  1a:	00 c0       	rjmp	.+0      	; 0x1c <LED_ON+0x1c>
	{
			switch(copy_port)
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	28 2f       	mov	r18, r24
  20:	30 e0       	ldi	r19, 0x00	; 0
  22:	3d 83       	std	Y+5, r19	; 0x05
  24:	2c 83       	std	Y+4, r18	; 0x04
  26:	8c 81       	ldd	r24, Y+4	; 0x04
  28:	9d 81       	ldd	r25, Y+5	; 0x05
  2a:	81 30       	cpi	r24, 0x01	; 1
  2c:	91 05       	cpc	r25, r1
  2e:	01 f0       	breq	.+0      	; 0x30 <LED_ON+0x30>
  30:	2c 81       	ldd	r18, Y+4	; 0x04
  32:	3d 81       	ldd	r19, Y+5	; 0x05
  34:	22 30       	cpi	r18, 0x02	; 2
  36:	31 05       	cpc	r19, r1
  38:	04 f4       	brge	.+0      	; 0x3a <LED_ON+0x3a>
  3a:	8c 81       	ldd	r24, Y+4	; 0x04
  3c:	9d 81       	ldd	r25, Y+5	; 0x05
  3e:	00 97       	sbiw	r24, 0x00	; 0
  40:	01 f0       	breq	.+0      	; 0x42 <LED_ON+0x42>
  42:	00 c0       	rjmp	.+0      	; 0x44 <LED_ON+0x44>
  44:	2c 81       	ldd	r18, Y+4	; 0x04
  46:	3d 81       	ldd	r19, Y+5	; 0x05
  48:	22 30       	cpi	r18, 0x02	; 2
  4a:	31 05       	cpc	r19, r1
  4c:	01 f0       	breq	.+0      	; 0x4e <LED_ON+0x4e>
  4e:	8c 81       	ldd	r24, Y+4	; 0x04
  50:	9d 81       	ldd	r25, Y+5	; 0x05
  52:	83 30       	cpi	r24, 0x03	; 3
  54:	91 05       	cpc	r25, r1
  56:	01 f0       	breq	.+0      	; 0x58 <LED_ON+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <LED_ON+0x5a>
			{
				case DIO_PORT_A : SET_BIT(PORT_A,copy_pin); break;
  5a:	ab e3       	ldi	r26, 0x3B	; 59
  5c:	b0 e0       	ldi	r27, 0x00	; 0
  5e:	eb e3       	ldi	r30, 0x3B	; 59
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	80 81       	ld	r24, Z
  64:	48 2f       	mov	r20, r24
  66:	8b 81       	ldd	r24, Y+3	; 0x03
  68:	28 2f       	mov	r18, r24
  6a:	30 e0       	ldi	r19, 0x00	; 0
  6c:	81 e0       	ldi	r24, 0x01	; 1
  6e:	90 e0       	ldi	r25, 0x00	; 0
  70:	02 2e       	mov	r0, r18
  72:	00 c0       	rjmp	.+0      	; 0x74 <LED_ON+0x74>
  74:	88 0f       	add	r24, r24
  76:	99 1f       	adc	r25, r25
  78:	0a 94       	dec	r0
  7a:	02 f4       	brpl	.+0      	; 0x7c <LED_ON+0x7c>
  7c:	84 2b       	or	r24, r20
  7e:	8c 93       	st	X, r24
  80:	00 c0       	rjmp	.+0      	; 0x82 <LED_ON+0x82>
				case DIO_PORT_B : SET_BIT(PORT_B,copy_pin); break;
  82:	a8 e3       	ldi	r26, 0x38	; 56
  84:	b0 e0       	ldi	r27, 0x00	; 0
  86:	e8 e3       	ldi	r30, 0x38	; 56
  88:	f0 e0       	ldi	r31, 0x00	; 0
  8a:	80 81       	ld	r24, Z
  8c:	48 2f       	mov	r20, r24
  8e:	8b 81       	ldd	r24, Y+3	; 0x03
  90:	28 2f       	mov	r18, r24
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	81 e0       	ldi	r24, 0x01	; 1
  96:	90 e0       	ldi	r25, 0x00	; 0
  98:	02 2e       	mov	r0, r18
  9a:	00 c0       	rjmp	.+0      	; 0x9c <LED_ON+0x9c>
  9c:	88 0f       	add	r24, r24
  9e:	99 1f       	adc	r25, r25
  a0:	0a 94       	dec	r0
  a2:	02 f4       	brpl	.+0      	; 0xa4 <LED_ON+0xa4>
  a4:	84 2b       	or	r24, r20
  a6:	8c 93       	st	X, r24
  a8:	00 c0       	rjmp	.+0      	; 0xaa <LED_ON+0xaa>
				case DIO_PORT_C : SET_BIT(PORT_C,copy_pin); break;
  aa:	a5 e3       	ldi	r26, 0x35	; 53
  ac:	b0 e0       	ldi	r27, 0x00	; 0
  ae:	e5 e3       	ldi	r30, 0x35	; 53
  b0:	f0 e0       	ldi	r31, 0x00	; 0
  b2:	80 81       	ld	r24, Z
  b4:	48 2f       	mov	r20, r24
  b6:	8b 81       	ldd	r24, Y+3	; 0x03
  b8:	28 2f       	mov	r18, r24
  ba:	30 e0       	ldi	r19, 0x00	; 0
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	90 e0       	ldi	r25, 0x00	; 0
  c0:	02 2e       	mov	r0, r18
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <LED_ON+0xc4>
  c4:	88 0f       	add	r24, r24
  c6:	99 1f       	adc	r25, r25
  c8:	0a 94       	dec	r0
  ca:	02 f4       	brpl	.+0      	; 0xcc <LED_ON+0xcc>
  cc:	84 2b       	or	r24, r20
  ce:	8c 93       	st	X, r24
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <LED_ON+0xd2>
				case DIO_PORT_D : SET_BIT(PORT_D,copy_pin); break;
  d2:	a2 e3       	ldi	r26, 0x32	; 50
  d4:	b0 e0       	ldi	r27, 0x00	; 0
  d6:	e2 e3       	ldi	r30, 0x32	; 50
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	80 81       	ld	r24, Z
  dc:	48 2f       	mov	r20, r24
  de:	8b 81       	ldd	r24, Y+3	; 0x03
  e0:	28 2f       	mov	r18, r24
  e2:	30 e0       	ldi	r19, 0x00	; 0
  e4:	81 e0       	ldi	r24, 0x01	; 1
  e6:	90 e0       	ldi	r25, 0x00	; 0
  e8:	02 2e       	mov	r0, r18
  ea:	00 c0       	rjmp	.+0      	; 0xec <LED_ON+0xec>
  ec:	88 0f       	add	r24, r24
  ee:	99 1f       	adc	r25, r25
  f0:	0a 94       	dec	r0
  f2:	02 f4       	brpl	.+0      	; 0xf4 <LED_ON+0xf4>
  f4:	84 2b       	or	r24, r20
  f6:	8c 93       	st	X, r24
  f8:	00 c0       	rjmp	.+0      	; 0xfa <LED_ON+0xfa>
				default : Local_Status_Error = FUNCTION_NOT_OK ;
  fa:	81 e0       	ldi	r24, 0x01	; 1
  fc:	89 83       	std	Y+1, r24	; 0x01
  fe:	00 c0       	rjmp	.+0      	; 0x100 <LED_ON+0x100>
			}
	}
	else
	{
		Local_Status_Error = FUNCTION_NOT_OK ;
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_Status_Error;
 104:	89 81       	ldd	r24, Y+1	; 0x01
}
 106:	0f 90       	pop	r0
 108:	0f 90       	pop	r0
 10a:	0f 90       	pop	r0
 10c:	0f 90       	pop	r0
 10e:	0f 90       	pop	r0
 110:	cf 91       	pop	r28
 112:	df 91       	pop	r29
 114:	08 95       	ret

Disassembly of section .text.LED_OFF:

00000000 <LED_OFF>:
#define NULL 				0
#define FUNCTION_IS_OK 		0
#define FUNCTION_NOT_OK 	1

u8 LED_ON (u8 copy_port , u8 copy_pin)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LED_OFF+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LED_OFF+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8a 83       	std	Y+2, r24	; 0x02
  10:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_Status_Error = FUNCTION_IS_OK ;
  12:	19 82       	std	Y+1, r1	; 0x01
	if(copy_pin<=DIO_PIN_7)
  14:	8b 81       	ldd	r24, Y+3	; 0x03
  16:	88 30       	cpi	r24, 0x08	; 8
  18:	00 f0       	brcs	.+0      	; 0x1a <LED_OFF+0x1a>
  1a:	00 c0       	rjmp	.+0      	; 0x1c <LED_OFF+0x1c>
	{
			switch(copy_port)
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	28 2f       	mov	r18, r24
  20:	30 e0       	ldi	r19, 0x00	; 0
  22:	3d 83       	std	Y+5, r19	; 0x05
  24:	2c 83       	std	Y+4, r18	; 0x04
  26:	8c 81       	ldd	r24, Y+4	; 0x04
  28:	9d 81       	ldd	r25, Y+5	; 0x05
  2a:	81 30       	cpi	r24, 0x01	; 1
  2c:	91 05       	cpc	r25, r1
  2e:	01 f0       	breq	.+0      	; 0x30 <LED_OFF+0x30>
  30:	2c 81       	ldd	r18, Y+4	; 0x04
  32:	3d 81       	ldd	r19, Y+5	; 0x05
  34:	22 30       	cpi	r18, 0x02	; 2
  36:	31 05       	cpc	r19, r1
  38:	04 f4       	brge	.+0      	; 0x3a <LED_OFF+0x3a>
  3a:	8c 81       	ldd	r24, Y+4	; 0x04
  3c:	9d 81       	ldd	r25, Y+5	; 0x05
  3e:	00 97       	sbiw	r24, 0x00	; 0
  40:	01 f0       	breq	.+0      	; 0x42 <LED_OFF+0x42>
  42:	00 c0       	rjmp	.+0      	; 0x44 <LED_OFF+0x44>
  44:	2c 81       	ldd	r18, Y+4	; 0x04
  46:	3d 81       	ldd	r19, Y+5	; 0x05
  48:	22 30       	cpi	r18, 0x02	; 2
  4a:	31 05       	cpc	r19, r1
  4c:	01 f0       	breq	.+0      	; 0x4e <LED_OFF+0x4e>
  4e:	8c 81       	ldd	r24, Y+4	; 0x04
  50:	9d 81       	ldd	r25, Y+5	; 0x05
  52:	83 30       	cpi	r24, 0x03	; 3
  54:	91 05       	cpc	r25, r1
  56:	01 f4       	brne	.+0      	; 0x58 <LED_OFF+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <LED_OFF+0x5a>
			{
				case DIO_PORT_A : SET_BIT(PORT_A,copy_pin); break;
  5a:	00 c0       	rjmp	.+0      	; 0x5c <LED_OFF+0x5c>
  5c:	ab e3       	ldi	r26, 0x3B	; 59
  5e:	b0 e0       	ldi	r27, 0x00	; 0
  60:	eb e3       	ldi	r30, 0x3B	; 59
  62:	f0 e0       	ldi	r31, 0x00	; 0
  64:	80 81       	ld	r24, Z
  66:	48 2f       	mov	r20, r24
  68:	8b 81       	ldd	r24, Y+3	; 0x03
  6a:	28 2f       	mov	r18, r24
  6c:	30 e0       	ldi	r19, 0x00	; 0
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	90 e0       	ldi	r25, 0x00	; 0
  72:	02 2e       	mov	r0, r18
  74:	00 c0       	rjmp	.+0      	; 0x76 <LED_OFF+0x76>
  76:	88 0f       	add	r24, r24
  78:	99 1f       	adc	r25, r25
  7a:	0a 94       	dec	r0
  7c:	02 f4       	brpl	.+0      	; 0x7e <LED_OFF+0x7e>
  7e:	80 95       	com	r24
  80:	84 23       	and	r24, r20
				case DIO_PORT_B : SET_BIT(PORT_B,copy_pin); break;
  82:	8c 93       	st	X, r24
  84:	00 c0       	rjmp	.+0      	; 0x86 <LED_OFF+0x86>
  86:	a8 e3       	ldi	r26, 0x38	; 56
  88:	b0 e0       	ldi	r27, 0x00	; 0
  8a:	e8 e3       	ldi	r30, 0x38	; 56
  8c:	f0 e0       	ldi	r31, 0x00	; 0
  8e:	80 81       	ld	r24, Z
  90:	48 2f       	mov	r20, r24
  92:	8b 81       	ldd	r24, Y+3	; 0x03
  94:	28 2f       	mov	r18, r24
  96:	30 e0       	ldi	r19, 0x00	; 0
  98:	81 e0       	ldi	r24, 0x01	; 1
  9a:	90 e0       	ldi	r25, 0x00	; 0
  9c:	02 2e       	mov	r0, r18
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <LED_OFF+0xa0>
  a0:	88 0f       	add	r24, r24
  a2:	99 1f       	adc	r25, r25
  a4:	0a 94       	dec	r0
  a6:	02 f4       	brpl	.+0      	; 0xa8 <LED_OFF+0xa8>
  a8:	80 95       	com	r24
				case DIO_PORT_C : SET_BIT(PORT_C,copy_pin); break;
  aa:	84 23       	and	r24, r20
  ac:	8c 93       	st	X, r24
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <LED_OFF+0xb0>
  b0:	a5 e3       	ldi	r26, 0x35	; 53
  b2:	b0 e0       	ldi	r27, 0x00	; 0
  b4:	e5 e3       	ldi	r30, 0x35	; 53
  b6:	f0 e0       	ldi	r31, 0x00	; 0
  b8:	80 81       	ld	r24, Z
  ba:	48 2f       	mov	r20, r24
  bc:	8b 81       	ldd	r24, Y+3	; 0x03
  be:	28 2f       	mov	r18, r24
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	81 e0       	ldi	r24, 0x01	; 1
  c4:	90 e0       	ldi	r25, 0x00	; 0
  c6:	02 2e       	mov	r0, r18
  c8:	00 c0       	rjmp	.+0      	; 0xca <LED_OFF+0xca>
  ca:	88 0f       	add	r24, r24
  cc:	99 1f       	adc	r25, r25
  ce:	0a 94       	dec	r0
  d0:	02 f4       	brpl	.+0      	; 0xd2 <LED_OFF+0xd2>
				case DIO_PORT_D : SET_BIT(PORT_D,copy_pin); break;
  d2:	80 95       	com	r24
  d4:	84 23       	and	r24, r20
  d6:	8c 93       	st	X, r24
  d8:	00 c0       	rjmp	.+0      	; 0xda <LED_OFF+0xda>
  da:	a2 e3       	ldi	r26, 0x32	; 50
  dc:	b0 e0       	ldi	r27, 0x00	; 0
  de:	e2 e3       	ldi	r30, 0x32	; 50
  e0:	f0 e0       	ldi	r31, 0x00	; 0
  e2:	80 81       	ld	r24, Z
  e4:	48 2f       	mov	r20, r24
  e6:	8b 81       	ldd	r24, Y+3	; 0x03
  e8:	28 2f       	mov	r18, r24
  ea:	30 e0       	ldi	r19, 0x00	; 0
  ec:	81 e0       	ldi	r24, 0x01	; 1
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	02 2e       	mov	r0, r18
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <LED_OFF+0xf4>
  f4:	88 0f       	add	r24, r24
  f6:	99 1f       	adc	r25, r25
  f8:	0a 94       	dec	r0
				default : Local_Status_Error = FUNCTION_NOT_OK ;
  fa:	02 f4       	brpl	.+0      	; 0xfc <LED_OFF+0xfc>
  fc:	80 95       	com	r24
  fe:	84 23       	and	r24, r20
			}
	}
	else
	{
		Local_Status_Error = FUNCTION_NOT_OK ;
 100:	8c 93       	st	X, r24
 102:	00 c0       	rjmp	.+0      	; 0x104 <LED_OFF+0x104>
	}
	return Local_Status_Error;
 104:	81 e0       	ldi	r24, 0x01	; 1
}
 106:	89 83       	std	Y+1, r24	; 0x01
 108:	00 c0       	rjmp	.+0      	; 0x10a <LED_OFF+0x10a>
 10a:	81 e0       	ldi	r24, 0x01	; 1
 10c:	89 83       	std	Y+1, r24	; 0x01
 10e:	89 81       	ldd	r24, Y+1	; 0x01
 110:	0f 90       	pop	r0
 112:	0f 90       	pop	r0
 114:	0f 90       	pop	r0
 116:	0f 90       	pop	r0
 118:	0f 90       	pop	r0
 11a:	cf 91       	pop	r28
 11c:	df 91       	pop	r29
 11e:	08 95       	ret

Disassembly of section .text.LED_ALL_PORT_ON:

00000000 <LED_ALL_PORT_ON>:
#define NULL 				0
#define FUNCTION_IS_OK 		0
#define FUNCTION_NOT_OK 	1

u8 LED_ON (u8 copy_port , u8 copy_pin)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LED_ALL_PORT_ON+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LED_ALL_PORT_ON+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
   e:	19 82       	std	Y+1, r1	; 0x01
  10:	8a 81       	ldd	r24, Y+2	; 0x02
	u8 Local_Status_Error = FUNCTION_IS_OK ;
  12:	28 2f       	mov	r18, r24
	if(copy_pin<=DIO_PIN_7)
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
	{
			switch(copy_port)
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	81 30       	cpi	r24, 0x01	; 1
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <LED_ALL_PORT_ON+0x24>
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	22 30       	cpi	r18, 0x02	; 2
  2a:	31 05       	cpc	r19, r1
  2c:	04 f4       	brge	.+0      	; 0x2e <LED_ALL_PORT_ON+0x2e>
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <LED_ALL_PORT_ON+0x36>
  36:	00 c0       	rjmp	.+0      	; 0x38 <LED_ALL_PORT_ON+0x38>
  38:	2b 81       	ldd	r18, Y+3	; 0x03
  3a:	3c 81       	ldd	r19, Y+4	; 0x04
  3c:	22 30       	cpi	r18, 0x02	; 2
  3e:	31 05       	cpc	r19, r1
  40:	01 f0       	breq	.+0      	; 0x42 <LED_ALL_PORT_ON+0x42>
  42:	8b 81       	ldd	r24, Y+3	; 0x03
  44:	9c 81       	ldd	r25, Y+4	; 0x04
  46:	83 30       	cpi	r24, 0x03	; 3
  48:	91 05       	cpc	r25, r1
  4a:	01 f0       	breq	.+0      	; 0x4c <LED_ALL_PORT_ON+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <LED_ALL_PORT_ON+0x4e>
  4e:	eb e3       	ldi	r30, 0x3B	; 59
  50:	f0 e0       	ldi	r31, 0x00	; 0
  52:	8f ef       	ldi	r24, 0xFF	; 255
  54:	80 83       	st	Z, r24
  56:	00 c0       	rjmp	.+0      	; 0x58 <LED_ALL_PORT_ON+0x58>
  58:	e8 e3       	ldi	r30, 0x38	; 56
			{
				case DIO_PORT_A : SET_BIT(PORT_A,copy_pin); break;
  5a:	f0 e0       	ldi	r31, 0x00	; 0
  5c:	8f ef       	ldi	r24, 0xFF	; 255
  5e:	80 83       	st	Z, r24
  60:	00 c0       	rjmp	.+0      	; 0x62 <LED_ALL_PORT_ON+0x62>
  62:	e5 e3       	ldi	r30, 0x35	; 53
  64:	f0 e0       	ldi	r31, 0x00	; 0
  66:	8f ef       	ldi	r24, 0xFF	; 255
  68:	80 83       	st	Z, r24
  6a:	00 c0       	rjmp	.+0      	; 0x6c <LED_ALL_PORT_ON+0x6c>
  6c:	e2 e3       	ldi	r30, 0x32	; 50
  6e:	f0 e0       	ldi	r31, 0x00	; 0
  70:	8f ef       	ldi	r24, 0xFF	; 255
  72:	80 83       	st	Z, r24
  74:	00 c0       	rjmp	.+0      	; 0x76 <LED_ALL_PORT_ON+0x76>
  76:	81 e0       	ldi	r24, 0x01	; 1
  78:	89 83       	std	Y+1, r24	; 0x01
  7a:	89 81       	ldd	r24, Y+1	; 0x01
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
				case DIO_PORT_B : SET_BIT(PORT_B,copy_pin); break;
  82:	0f 90       	pop	r0
  84:	cf 91       	pop	r28
  86:	df 91       	pop	r29
  88:	08 95       	ret

Disassembly of section .text.LED_ALL_PORT_OFF:

00000000 <LED_ALL_PORT_OFF>:
#define NULL 				0
#define FUNCTION_IS_OK 		0
#define FUNCTION_NOT_OK 	1

u8 LED_ON (u8 copy_port , u8 copy_pin)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <LED_ALL_PORT_OFF+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <LED_ALL_PORT_OFF+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	8a 83       	std	Y+2, r24	; 0x02
   e:	19 82       	std	Y+1, r1	; 0x01
  10:	8a 81       	ldd	r24, Y+2	; 0x02
	u8 Local_Status_Error = FUNCTION_IS_OK ;
  12:	28 2f       	mov	r18, r24
	if(copy_pin<=DIO_PIN_7)
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
	{
			switch(copy_port)
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	81 30       	cpi	r24, 0x01	; 1
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <LED_ALL_PORT_OFF+0x24>
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	22 30       	cpi	r18, 0x02	; 2
  2a:	31 05       	cpc	r19, r1
  2c:	04 f4       	brge	.+0      	; 0x2e <LED_ALL_PORT_OFF+0x2e>
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <LED_ALL_PORT_OFF+0x36>
  36:	00 c0       	rjmp	.+0      	; 0x38 <LED_ALL_PORT_OFF+0x38>
  38:	2b 81       	ldd	r18, Y+3	; 0x03
  3a:	3c 81       	ldd	r19, Y+4	; 0x04
  3c:	22 30       	cpi	r18, 0x02	; 2
  3e:	31 05       	cpc	r19, r1
  40:	01 f0       	breq	.+0      	; 0x42 <LED_ALL_PORT_OFF+0x42>
  42:	8b 81       	ldd	r24, Y+3	; 0x03
  44:	9c 81       	ldd	r25, Y+4	; 0x04
  46:	83 30       	cpi	r24, 0x03	; 3
  48:	91 05       	cpc	r25, r1
  4a:	01 f0       	breq	.+0      	; 0x4c <LED_ALL_PORT_OFF+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <LED_ALL_PORT_OFF+0x4e>
  4e:	eb e3       	ldi	r30, 0x3B	; 59
  50:	f0 e0       	ldi	r31, 0x00	; 0
  52:	10 82       	st	Z, r1
  54:	00 c0       	rjmp	.+0      	; 0x56 <LED_ALL_PORT_OFF+0x56>
  56:	e8 e3       	ldi	r30, 0x38	; 56
  58:	f0 e0       	ldi	r31, 0x00	; 0
			{
				case DIO_PORT_A : SET_BIT(PORT_A,copy_pin); break;
  5a:	10 82       	st	Z, r1
  5c:	00 c0       	rjmp	.+0      	; 0x5e <LED_ALL_PORT_OFF+0x5e>
  5e:	e5 e3       	ldi	r30, 0x35	; 53
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	10 82       	st	Z, r1
  64:	00 c0       	rjmp	.+0      	; 0x66 <LED_ALL_PORT_OFF+0x66>
  66:	e2 e3       	ldi	r30, 0x32	; 50
  68:	f0 e0       	ldi	r31, 0x00	; 0
  6a:	10 82       	st	Z, r1
  6c:	00 c0       	rjmp	.+0      	; 0x6e <LED_ALL_PORT_OFF+0x6e>
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	89 83       	std	Y+1, r24	; 0x01
  72:	89 81       	ldd	r24, Y+1	; 0x01
  74:	0f 90       	pop	r0
  76:	0f 90       	pop	r0
  78:	0f 90       	pop	r0
  7a:	0f 90       	pop	r0
  7c:	cf 91       	pop	r28
  7e:	df 91       	pop	r29
  80:	08 95       	ret
