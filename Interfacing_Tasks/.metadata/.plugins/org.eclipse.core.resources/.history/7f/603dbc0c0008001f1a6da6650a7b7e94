#include "../../LIB/STD_TYPES.h"
#include "../../LIB/BIT_MATH.h"
#include "../../MCAL/PORT/PORT_interface.h"
#include "../../HAL/KEYPAD_DRIVER/KPD_interface.h"
#include "../../HAL/LCD_DRIVER/LCD_interface.h"
#include <util/delay.h>
#include "calc.h"

#define KPD_NO_PRESSED_KEY      0xff

/* ASCII values */
#define ASCII_0                 48
#define ASCII_9                 57
#define ASCII_PLUS              43
#define ASCII_MINUS             45
#define ASCII_MULTIPLY          42
#define ASCII_DIVIDE            47
#define ASCII_EQUALS            61
#define ASCII_CLEAR             35   // ASCII for '#'

#define MAX_OPERANDS            10   // Maximum number of operands
#define MAX_OPERATORS           (MAX_OPERANDS - 1)  // Maximum number of operators

int main(void) {
    START_CALC();

    s32 NUM[MAX_OPERANDS] = {0};
    u8 OP[MAX_OPERATORS] = {0};
    s32 RES = 0;
    u8 NUM_INDEX = 0;
    u8 OP_INDEX = 0;
    u8 FLOAT_FLAG = 0;
    float F_RES = 0;

    while (1) {
        s32 RET_KEY = KPD_GetPressedkey();
        if (RET_KEY == ASCII_CLEAR) {
            // Reset calculator
            lcd_clear();
            RESET_CALC(NUM, OP, &RES, &NUM_INDEX, &OP_INDEX, &FLOAT_FLAG);
        } else if ((RET_KEY >= ASCII_0 && RET_KEY <= ASCII_9) && OP_INDEX == NUM_INDEX - 1) {
            // Current input is part of the next operand
            NUM[NUM_INDEX] = (NUM[NUM_INDEX] * 10) + (RET_KEY - ASCII_0);
            lcd_send_data(RET_KEY);
        } else if ((RET_KEY == ASCII_PLUS || RET_KEY == ASCII_MINUS || RET_KEY == ASCII_MULTIPLY || RET_KEY == ASCII_DIVIDE) &&
                   OP_INDEX < MAX_OPERATORS) {
            // Current input is an operator
            OP[OP_INDEX] = RET_KEY;
            NUM_INDEX++;
            OP_INDEX++;
            lcd_send_data(RET_KEY);
        } else if (RET_KEY == ASCII_EQUALS) {
            // Perform calculation
            if (NUM_INDEX > OP_INDEX) {
                // Last operand is not yet entered
                continue;
            }
            RES = NUM[0];
            for (u8 i = 0; i < OP_INDEX; i++) {
                switch (OP[i]) {
                    case ASCII_PLUS:
                        RES += NUM[i + 1];
                        break;
                    case ASCII_MINUS:
                        RES -= NUM[i + 1];
                        break;
                    case ASCII_MULTIPLY:
                        RES *= NUM[i + 1];
                        break;
                    case ASCII_DIVIDE:
                        if (NUM[i + 1] != 0) {
                            if (RES % NUM[i + 1] == 0) {
                                RES /= NUM[i + 1];
                            } else {
                                FLOAT_FLAG = 1;
                                F_RES = (float)RES / (float)NUM[i + 1];
                            }
                        } else {
                            // Handle division by zero error
                            lcd_send_string("Error: Division by zero");
                            _delay_ms(2000);
                            lcd_clear();
                            RESET_CALC(NUM, OP, &RES, &NUM_INDEX, &OP_INDEX, &FLOAT_FLAG);
                            break;
                        }
                        break;
                }
            }
            // Display result
            lcd_go_to_xy(1, 0);
            if (FLOAT_FLAG == 1) {
                lcd_show_float(F_RES);
            } else {
                lcd_show_number(RES);
            }
            RESET_CALC(NUM, OP, &RES, &NUM_INDEX, &OP_INDEX, &FLOAT_FLAG);
        }
    }
    return 0;
}
