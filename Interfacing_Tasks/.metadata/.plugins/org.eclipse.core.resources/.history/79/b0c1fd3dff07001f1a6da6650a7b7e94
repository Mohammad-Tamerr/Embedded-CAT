#include "../../LIB/STD_TYPES.h"
#include "../../LIB/BIT_MATH.h"
#include "../../MCAL/PORT/PORT_interface.h"
#include "../../HAL/KEYPAD_DRIVER/KPD_interface.h"
#include "../../HAL/LCD_DRIVER/LCD_interface.h"
#include <util/delay.h>
#include "calc.h"

#define KPD_NO_PRESSED_KEY      0xff

/* ASCII values */
#define ASCII_0                 48
#define ASCII_9                 57
#define ASCII_PLUS              43
#define ASCII_MINUS             45
#define ASCII_MULTIPLY          42
#define ASCII_DIVIDE            47
#define ASCII_EQUALS            61
#define ASCII_CLEAR             35   // ASCII for '#'

#define MAX_OPERANDS            10   // Maximum number of operands
#define MAX_OPERATORS           (MAX_OPERANDS - 1)  // Maximum number of operators

int main(void) {
    START_CALC();

    s32 operands[MAX_OPERANDS] = {0};
    u8 operators[MAX_OPERATORS] = {0};
    s32 result = 0;
    u8 operand_index = 0;
    u8 operator_index = 0;
    u8 float_flag = 0;
    u8 f_result = 0;


    while (1) {
        s32 key = KPD_GetPressedKey();
        if (key == ASCII_CLEAR) {
            // Reset calculator
            lcd_clear();
            RESET_CALC(&operands[0], &operators[0], &result, &operand_index, &operator_index, &float_flag);
        } else if ((key >= ASCII_0 && key <= ASCII_9) && operator_index == operand_index - 1) {
            // Current input is part of the next operand
            operands[operand_index] = (operands[operand_index] * 10) + (key - ASCII_0);
            lcd_send_data(key);
        } else if ((key == ASCII_PLUS || key == ASCII_MINUS || key == ASCII_MULTIPLY || key == ASCII_DIVIDE) &&
                   operator_index < MAX_OPERATORS) {
            // Current input is an operator
            operators[operator_index] = key;
            operand_index++;
            operator_index++;
            lcd_send_data(key);
        } else if (key == ASCII_EQUALS) {
            // Perform calculations
            if (operand_index > operator_index) {
                // Last operand is not yet entered
                continue;
            }
            result = operands[0];
            for (u8 i = 0; i < operator_index; i++) {
                switch (operators[i]) {
                    case ASCII_PLUS:
                        result += operands[i + 1];
                        break;
                    case ASCII_MINUS:
                        result -= operands[i + 1];
                        break;
                    case ASCII_MULTIPLY:
                        result *= operands[i + 1];
                        break;
                    case ASCII_DIVIDE:
                        if (operands[i + 1] != 0) {
                            if (result % operands[i + 1] == 0) {
                                result /= operands[i + 1];
                            } else {
                                float_flag = 1;
                                f_result = (float)result / (float)operands[i + 1];
                            }
                        } else {
                            // Handle division by zero error
                            lcd_send_string("Error: Division by zero");
                            _delay_ms(2000);
                            lcd_clear();
                            RESET_CALC(&operands[0], &operators[0], &result, &operand_index, &operator_index, &float_flag);
                            break;
                        }
                        break;
                }
            }
            // Display result
            lcd_go_to_xy(1, 0);
            if (float_flag == 1) {
                lcd_show_float(f_result);
            } else {
                lcd_show_number(result);
            }
            RESET_CALC(&operands[0], &operators[0], &result, &operand_index, &operator_index, &float_flag);
        }
    }
    return 0;
}
